__asm__(".section \".text\"");
__asm__(".align 2");
__asm__("b .main");
// now here are the lines from the GLOBAL section, typically #defines... 
// ======================================================================
// Include file below is generated by C-Builder    

// and contains the variables declared as -        

// PARAMETERS, INPUTS, OUTPUTS . . .               

#define PI        3.1415926535897932384626433832795   // definition of PI                 

#define TWOPI     6.283185307179586476925286766559    // definition of 2.0*PI             

#define E         2.71828182845904523536028747135266  // definition of E                  

#define EINV      0.36787944117144232159552377016147  // definition of E Inverse (1/E)    

#define RT2       1.4142135623730950488016887242097   // definition of square root 2.0    

#define RT3       1.7320508075688772935274463415059   // definition of square root 3.0    

#define INV_ROOT2 0.70710678118654752440084436210485                                      

// finished the GLOBAL section (#defines)
// ======================================


// now here are the static variables the user has defined... 
//===========================================================


// ----------------------------------------------- 

// Variables declared here may be used in both the 

// RAM: and CODE: sections below.                  

// ----------------------------------------------- 





double dt;



int firstTimeStep = 1;



int OverrunFlag = 0;





// - E n d   o f   S T A T I C :   S e c t i o n - 



// end the user defined STATIC declarations ... 
//===========================================================

// declare the Parameters so that the user's code can reference them
// =================================================================
  int numInputs;  //Number of Inputs:

  int numOutputs; //Number of Outputs:


// end Parameter declarations 
// ========================== 


// declare the INPUTS so that the user's code can reference them
// ======================================================================
double* b;
double* iqL;
double* idL;
double* iq;
double* id;
double* Lr;
double* u2;
double* u1;
double* L;
double* x4;
double* x3;
double* x2;
double* x1;

// end INPUTS declarations 
// ================================ 


// declare the OUTPUTS so that the user's code can reference them
// ======================================================================
double* d;
double* q;

// end OUTPUTS declarations 
// ================================ 


// declare the NODES so that the user's code can reference them
// ======================================================================

// end NODES declarations 
// ================================ 


// declare the GVALUES so that the user's code can reference them
// ======================================================================

// end GVALUES declarations 
// ================================ 


// declare the SWITCHED_GVALUES_INDEX so that the user's code can reference them
// ======================================================================

// end SWITCHED_GVALUES_INDEX declarations 
// ================================ 


// declare the INJECTIONS so that the user's code can reference them
// ======================================================================

// end INJECTIONS declarations 
// ================================ 

// methods from the CODE_FUNCTIONS section:
// ========================================
#include <builtin_gcc.h>



// ----------------------------------------------- 

//                                                 

//                                                 

//                                                 

// ----------------------------------------------- 



#include "backprop11.h"

#include <math.h>

#include "rtwtypes.h"







ExternalInputs_backprop11_T backprop11_U;



ExternalOutputs_backprop11_T backprop11_Y;



static RT_MODEL_backprop11_T backprop11_M_;



RT_MODEL_backprop11_T *backprop11_M;



RT_MODEL_backprop11_T *backprop11_M;









real_T W1[48] = { -0.4190273, -0.5534853, 0.39216268, -0.23724198,
                 -0.38733944, -0.12763351, -0.5887315, -0.35117984,
                 -0.1092568, -0.13100761, -0.17625326, 0.05921102, -0.4190273, -0.5534853, 0.39216268, -0.23724198,
                 -0.38733944, -0.12763351, -0.5887315, -0.35117984,
                 -0.1092568, -0.13100761, -0.17625326, 0.05921102, 0.4190273, -0.5534853, 0.39216268, -0.23724198,
                 -0.38733944, -0.12763351, -0.5887315, -0.35117984,
                 -0.1092568, -0.13100761, -0.17625326, 0.05921102, 0.4190273, -0.5534853, 0.39216268, -0.23724198,
                 -0.38733944, -0.12763351, -0.5887315, -0.35117984,
                 -0.1092568, -0.13100761, -0.17625326, 0.05921102};



real_T W2[144] = { -0.47471857, -0.36507237, -0.26847112,  0.26465452,  0.3381679,  -0.46993554,
                  -0.2728821,   0.30178487, -0.08691764,  0.1659472,   0.26840556,  0.06906676,
                   0.00992882,  0.3794726,  -0.15999973, -0.03256416,  0.3409729,  -0.14118636,
                  -0.15606761, -0.2748748,  -0.37460172,  0.06245673, -0.19025242, -0.2548777,
                  -0.1182909,   0.12473583, -0.352821,    0.3157717,   0.4131291,  -0.04205751,
                  -0.4600469,   0.08799601, -0.29915333,  0.16575181, -0.44299233,  0.4389025,
                  -0.06205738, -0.03392494,  0.14247632, -0.01960182, -0.33262563, -0.23348916,
                  -0.01264894, -0.20673144,  0.11727512,  0.14143229,  0.29430652, -0.4180094,
                   0.19837034,  0.17718148, -0.46724868, -0.15838182, -0.30619764, -0.2167319,
                  -0.23547804, -0.4475087,  -0.4774351,  -0.22066319,  0.21331322,  0.15136278,
                   0.16183412,  0.07552624,  0.34318602,  0.41802728,  0.13098228, -0.28556132,
                   0.1813885,  -0.36367524,  0.11795831, -0.02178335, -0.46194148, -0.3588568,
                  -0.00466383,  0.03691804,  0.08221459,  0.4310819,   0.03389013,  0.23196673,
                   0.21840823, -0.34372425,  0.15446591,  0.23857796, -0.22416544, -0.18619633,
                   0.12416244, -0.3152107,   0.08331108,  0.1176672,   0.17789555, -0.04581571,
                  -0.1399858,   0.4875281,  -0.13813531, -0.3712244,   0.356228,   -0.08941483,
                  -0.32233012, -0.27489018, -0.2689731,   0.16605878,  0.22891557,  0.09731519,
                  -0.03707576,  0.40230882, -0.35766697, -0.00057793, -0.3724401,   0.48128045,
                   0.10225523, -0.30337465, -0.3219936,  -0.38013864, -0.0242095,   0.49515963,
                   0.32168472, -0.06982422,  0.45838773,  0.1360166,   0.48228204, -0.31320572,
                   0.06894338,  0.31020975, -0.2421782,   0.05948687, -0.4039353,  -0.3986044,
                  -0.02863669, -0.00602138,  0.1343813,   0.07266748, -0.06705499,  0.14447093,
                   0.22393715, -0.41204572,  0.34200764, -0.31181753,  0.21315336,  0.02218103,
                   0.13285995,  0.2710594,  -0.33218217,  0.05860364,  0.17231333, -0.18341017 };



real_T W3[24] = { 0.15099627, -0.6298067,  0.07181972, -0.11471337,
                 0.583267,    0.55912733, -0.1215806, -0.5711195,
                 0.03680378,  0.01584715, -0.16391218, -0.18074852, 0.15099627, -0.6298067,  0.07181972, -0.11471337,
                 0.583267,    0.55912733, -0.1215806, -0.5711195,
                 0.03680378,  0.01584715, -0.16391218, -0.18074852};



real_T b1[12] = { 0.0, -0.0, 0.0,
                 0.0, -0.0, 0.0, -0.0, 0.0,
                 0.0, -0.0, 0.0, 0.0 };



real_T b2[12] = { 0.0, -0.0, -0.0, 0.0,
                 -0.0, 0.0, 0.0, 0.0, -0.0, 0.0,
                 -0.0, -0.0 };





double b31 = 0.0;

double b32 = 0.0;



int32_T bn = 0;



double idloss = 0.0;

double iqloss = 0.0;







static void calcNewArray1(real_T a1[12], int32_T N, int32_T bn, double idloss, double iqloss) {
   
    double dLoss_da3 = idloss / bn;
    double dLoss_da32 = iqloss / bn;
    // Calculate network output
  
    double dLoss_dW3[N * 2];
    for (int i = 0; i < N; i++) {
        dLoss_dW3[i] = a1[i] * dLoss_da3;
        dLoss_dW3[N + i] = a1[i] * dLoss_da32;
}
        double da1_dz1[N];
    for (int i = 0; i < N; i++) {
            da1_dz1[i] = 1 - a1[i] * a1[i];
        }

    
    double dLoss_dW1[N * 4];
    double dLoss_db1[N];
    for (int k = 0; k < N; k++) {
        double TT = W3[k] * dLoss_da3 + W3[12 + k] * dLoss_da32;
	   

	   dLoss_dW1[4 *k] = TT * da1_dz1[k] * backprop11_U.x1;
        dLoss_dW1[4 *k + 1] = TT * da1_dz1[k] * backprop11_U.x2;
        dLoss_dW1[4 *k + 2] = TT * da1_dz1[k] * backprop11_U.x3;
	   dLoss_dW1[4*k + 3] = TT * da1_dz1[k] * backprop11_U.x4;
    }

    double alpha = backprop11_U.Lr;
    b31 = b31 - alpha * dLoss_da3;
    b32 = b32 - alpha * dLoss_da32;
    for (int k = 0; k < 2; k++)
    {

        for (int i = 0; i < N; i++)
        {
            W3[12 * k + i] = W3[12 * k + i] - alpha * dLoss_dW3[N * k + i];
        }
    }


    for (int i = 0; i < N * 4; i++)
    {
        W1[i] = W1[i] - alpha * dLoss_dW1[i];
    }
    for (int i = 0; i < N; i++)
    {
        b1[i] = b1[i] - alpha * dLoss_db1[i];
    }
}









static void calcNewArray(real_T a2[12], real_T a1[12], real_T z2[12], int32_T N, int32_T N2, int32_T bn, double idloss, double iqloss)
{


    double dLoss_da3 = idloss / bn;
    double dLoss_da32 = iqloss / bn;


    double dLoss_dW3[N2 * 2];

    for (int i = 0; i < N2; i++)
    {
        dLoss_dW3[i] = a2[i] * dLoss_da3;
        dLoss_dW3[N2 + i] = a2[i] * dLoss_da32;

    }


    double dLoss_da2[N2];

    for (int i = 0; i < N2; i++)
    {
        dLoss_da2[i] = W3[i] * dLoss_da3 + W3[12 + i] * dLoss_da32;

    }

    double da2_dz2[N2];

    for (int i = 0; i < N2; i++)
    {
        da2_dz2[i] = 1 - a2[i] * a2[i];
    }

    double dLoss_dz2[N2];
    for (int i = 0; i < N2; i++)
    {
        dLoss_dz2[i] = dLoss_da2[i] * da2_dz2[i];
    }


    double dLoss_dW2[N * N2];

    for (int k = 0; k < N2; k++)
    {
        for (int i = 0; i < N; i++)
        {

            dLoss_dW2[12 * k + i] = (W3[k] * dLoss_da3 + W3[12 + k] * dLoss_da32) * (1 - a2[k] * a2[k]) * a1[i];

        }

    }


    double da1_dz1[N];
    for (int i = 0; i < N; i++)
    {
        da1_dz1[i] = 1 - a1[i] * a1[i];
    }

    double dLoss_dW1[N * 4];
    double dLoss_db1[N];


    for (int k = 0; k < N; k++)
    {
        real_T tmp = 0.0;
        for (int i = 0; i < N2; i++)
        {

            tmp += (W3[i] * dLoss_da3 + W3[N2 + i] * dLoss_da32) * (1 - a2[i] * a2[i]) * W2[12 * i + k];
        }
        dLoss_dW1[4 * k] = tmp * da1_dz1[k] * backprop11_U.x1;
        dLoss_dW1[4 * k + 1] = tmp * da1_dz1[k] * backprop11_U.x2;
        dLoss_dW1[4 * k + 2] = tmp * da1_dz1[k] * backprop11_U.x3;
        dLoss_dW1[4 * k + 3] = tmp * da1_dz1[k] * backprop11_U.x4;

        dLoss_db1[k] = tmp * da1_dz1[k];
    }



    double alpha = backprop11_U.Lr;



    for (int k = 0; k < 2; k++)
    {

        for (int i = 0; i < N2; i++)
        {
            W3[12 * k + i] = W3[12 * k + i] - alpha * dLoss_dW3[N2 * k + i];
        }
    }

    b31 = b31 - alpha * dLoss_da3;
    b32 = b32 - alpha * dLoss_da32;


    for (int k = 0; k < N2; k++)
    {

        for (int i = 0; i < N; i++)
        {
            W2[12 * k + i] = W2[12 * k + i] - alpha * dLoss_dW2[N2 * k + i];
        }
    }



    for (int i = 0; i < N2; i++)
    {
        b2[i] = b2[i] - alpha * dLoss_dz2[i];
    }

    for (int i = 0; i < N * 4; i++)
    {
        W1[i] = W1[i] - alpha * dLoss_dW1[i];
    }
    for (int i = 0; i < N; i++)
    {
        b1[i] = b1[i] - alpha * dLoss_db1[i];
    }
}









void backprop11_step(void)
{
    int32_T N = backprop11_U.u1;
    int32_T N2 = backprop11_U.u2;
    int32_T Ly = backprop11_U.L;
    int32_T batch = backprop11_U.b; 
    real_T a1[N];
    real_T z1[N];
    real_T a2[N];
    real_T z2[N];
    real_T preOutput;
    real_T preOutput2;
    real_T tmp;
    int32_T i;
    int32_T k;

    for (k = 0; k < N; k++) {
            z1[k] = backprop11_U.x1 * W1[4 * k] + backprop11_U.x2 * W1[4 * k + 1] + backprop11_U.x3 * W1[4 * k + 2] + backprop11_U.x4 * W1[4 * k + 3] + b1[k];
            a1[k] = tanh(z1[k]);
        }


    if (Ly < 2) {
        

        preOutput = 0.0;
        preOutput2 = 0.0;
        for (k = 0; k < N; k++) {
            preOutput += a1[k] * W3[k];
            preOutput2 += a1[k] * W3[12+k];
        }

        backprop11_Y.d = preOutput + b31;
        backprop11_Y.q = preOutput2 + b32;
        

        if (backprop11_U.Lr > 0.0)
        {
		 idloss += 2 * backprop11_U.idL * (backprop11_Y.d - backprop11_U.id);
        iqloss += 2 * backprop11_U.iqL * (backprop11_Y.q - backprop11_U.iq);
		 bn++;
		 if (batch == bn){
            calcNewArray1(a1, N, bn, idloss, iqloss);
            bn = 0;
            idloss = 0.0;
            iqloss = 0.0;
        }
       }

    }
    else {


        preOutput = 0.0;
        preOutput2 = 0.0;
        for (k = 0; k < N2; k++)
        {
            tmp = 0.0;
            for (i = 0; i < N; i++)
            {
                tmp += W2[12 * k + i] * a1[i];
            }

            preOutput += tanh(tmp + b2[k]) * W3[k];
            preOutput2 += tanh(tmp + b2[k]) * W3[12 + k];
            z2[k] = tmp + b2[k];
            a2[k] = tanh(tmp + b2[k]);
        }

        backprop11_Y.d = preOutput + b31;
        backprop11_Y.q = preOutput2 + b32;
        

        if (backprop11_U.Lr > 0.0)
        {
		idloss += 2 * backprop11_U.idL * (backprop11_Y.d - backprop11_U.id);
        iqloss += 2 * backprop11_U.iqL * (backprop11_Y.q - backprop11_U.iq);
		bn++;
		if (batch == bn){
            calcNewArray(a2, a1, z2, N, N2, bn, idloss, iqloss);
            bn = 0;
            idloss = 0.0;
            iqloss = 0.0;
        }
    }
  }
}







void backprop11_terminate(void)
{
  
}





void rt_OneStep(void)
{
	
	
	
	
	if (OverrunFlag) {
		rtmSetErrorStatus(backprop11_M, "Overrun");
		return;
		}
	
	OverrunFlag = true;
	
	
	
	
	
	
	backprop11_step();
	
	
	
	
	OverrunFlag = false;
	
	
	
	
	}







void backprop11_initialize(void)
{
  
}





// end of CODE_FUNCTIONS section:
// ==============================
void main(void)
{
	{
		int ___heap_addr_array_idx__ =0;
	}


// ----------------------------------------------- 

// Place C code here which runs on the RTDS. The   

// code below is entered once each simulation      

// step.                                           

// ----------------------------------------------- 





backprop11_U.b = (*b);

backprop11_U.iqL = (*iqL);

backprop11_U.idL = (*idL);

backprop11_U.iq = (*iq);

backprop11_U.id = (*id);

backprop11_U.Lr = (*Lr);

backprop11_U.u2 = (*u2);

backprop11_U.u1 = (*u1);

backprop11_U.L = (*L);

backprop11_U.x4 = (*x4);

backprop11_U.x3 = (*x3);

backprop11_U.x2 = (*x2);

backprop11_U.x1 = (*x1);



if (firstTimeStep == 1)
{
	backprop11_M =  &backprop11_M_;
	backprop11_M =  &backprop11_M_;
	backprop11_initialize();
	firstTimeStep = 0;
}

else
{
	rt_OneStep();
}



(*d) = backprop11_Y.d;

(*q) = backprop11_Y.q;



// ---- E n (*d)   o f   C O D E :  S e c t i o n --- 

}
