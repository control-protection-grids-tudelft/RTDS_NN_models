VERSION:
3.001

// Include file below is generated by C-Builder    
// and contains the variables declared as -        
// PARAMETERS, INPUTS, OUTPUTS . . .               
#include "SimpleNN1.h"

STATIC:

// ----------------------------------------------- 
// Variables declared here may be used in both the 
// RAM: and CODE: sections below.                  
// ----------------------------------------------- 


double dt;

int firstTimeStep = 1;

int OverrunFlag = 0;


// - E n d   o f   S T A T I C :   S e c t i o n - 

RAM_FUNCTIONS:

// ----------------------------------------------- 
// This section should contain any 'c' functions   
// to be called from the RAM section (either       
// RAM_PASS1 or RAM_PASS2). Example:               
//                                                 
// static double myFunction(double v1, double v2)  
// {                                               
//     return(v1*v2);                              
// }                                               
// ----------------------------------------------- 


RAM:

// ----------------------------------------------- 
// Place C code here which computes constants      
// required for the CODE: section below.  The C    
// code here is executed once, prior to the start  
// of the simulation case.                         
// ----------------------------------------------- 


dt= getTimeStep();


// ---- E n d   o f   R A M :   S e c t i o n ---- 

CODE_FUNCTIONS:

// ----------------------------------------------- 
//                                                 
//                                                 
//                                                 
// ----------------------------------------------- 

#include "backprops1.h"
#include <math.h>
#include "rtwtypes.h"



ExternalInputs_backprops1_T backprops1_U;

ExternalOutputs_backprops1_T backprops1_Y;

static RT_MODEL_backprops1_T backprops1_M_;

RT_MODEL_backprops1_T *backprops1_M;

RT_MODEL_backprops1_T *backprops1_M;


real_T W1[12] = {
    -6.6404492e-01, -3.9443225e-01,
    -4.4538104e-04,  4.9597317e-01,
    -7.9017895e-01,  5.9853339e-01, 
    -6.2414825e-01,  2.8735468e-01,
    -7.4953431e-01,  4.9562362e-01,
    -4.8426588e-04,  5.7064009e-01 };

real_T b1[6] = {-0.04221957,  0.00050526,  0.05357343, -0.04562575,  0.05250151, 0.00057177};

real_T W2[6] = {
    -3.7669787e-01, -1.2386947e-04, 3.9995238e-01, -5.0494623e-01,  3.7603214e-01, -1.4916796e-04  
};

double b2 = 0.06334419;

int32_T bn = 0;

double idloss = 0.0;


static void calcNewArray1(real_T z1[6], int32_T N, int32_T bn, double idloss) {
   
    double dLoss_da3 = idloss / bn;
    // Calculate network output
  
    double dLoss_dW3[N];
	double dLoss_dW1[N * 2];
    double dLoss_db1[N];
    double alpha = backprops1_U.Lr;

    for (int i = 0; i < N; i++) {
        dLoss_dW3[i] = z1[i] * dLoss_da3;
	   dLoss_db1[i] = W2[i] * dLoss_da3;
	dLoss_dW1[2 *i] = dLoss_db1[i] * backprops1_U.x1;
      dLoss_dW1[2 *i + 1] = dLoss_db1[i] * backprops1_U.x2;
	W2[i] = W2[i] - alpha * dLoss_dW3[i];
     b1[i] = b1[i] - alpha * dLoss_db1[i];
	W1[2*i] = W1[2*i] - alpha * dLoss_dW1[2*i];
	W1[2*i+1] = W1[2*i+1] - alpha * dLoss_dW1[2*i+1];
	   
}
    
    
    b2 = b2 - alpha * dLoss_da3;
    
    
}



void backprops1_step(void)
{
    int32_T batch = backprops1_U.b;
    int32_T N = backprops1_U.u1; 
    //real_T a1[N];
    real_T z1[N];
    real_T preOutput;
    int32_T i;
    int32_T k;

	preOutput = 0.0;
    for (k = 0; k < N; k++) {
            z1[k] = backprops1_U.x1 * W1[2 * k] + backprops1_U.x2 * W1[2 * k + 1] + b1[k];
		preOutput += z1[k] * W2[k];

        }        

    
        backprops1_Y.y = preOutput + b2;
        

        if (backprops1_U.Lr > 0.0)
        {
		 idloss += 2 * (backprops1_Y.y - backprops1_U.id);
    
		 bn++;
		 if (batch == bn){
            calcNewArray1(z1, N, bn, idloss);
            bn = 0;
            idloss = 0.0;
            
        }
       }

    }







void backprops1_terminate(void)
{
  
}


void rt_OneStep(void)
{
	
	
	
	
	if (OverrunFlag) {
		rtmSetErrorStatus(backprops1_M, "Overrun");
		return;
		}
	
	OverrunFlag = true;
	
	
	
	
	
	
	backprops1_step();
	
	
	
	
	OverrunFlag = false;
	
	
	
	
	}



void backprops1_initialize(void)
{
  
}


CODE:

// ----------------------------------------------- 
// Place C code here which runs on the RTDS. The   
// code below is entered once each simulation      
// step.                                           
// ----------------------------------------------- 


backprops1_U.a = a;
backprops1_U.b = b;
backprops1_U.id = id;
backprops1_U.Lr = Lr;
backprops1_U.u1 = u1;
backprops1_U.x2 = x2;
backprops1_U.x1 = x1;

if (firstTimeStep == 1)
{
	backprops1_M =  &backprops1_M_;
	backprops1_M =  &backprops1_M_;
	backprops1_initialize();
	firstTimeStep = 0;
}
else
{
	rt_OneStep();
}

y = backprops1_Y.y;

// ---- E n d   o f   C O D E :  S e c t i o n --- 

