VERSION:
3.001

// Include file below is generated by C-Builder      
// and contains the variables declared as -          
// PARAMETERS, INPUTS, OUTPUTS . . .                 
#include "lstmV2.h"


STATIC:

// -----------------------------------------------   
// Variables declared here may be used in both the   
// RAM: and CODE: sections below.                    
// -----------------------------------------------   
//    double dt;    

int N;
int Y;
int T;
int nodes;

int i;
int k;
int t;
int j;
int y;


double hloss[11] = {0.0};
double dhloss[11] = {0.0};
double Wloss[60] = {0.0};
double h[11] = {0.0};
double h_next[11] = {0.0};
double h_all[110] = {0.0};

double C[11] = {0.0};
double Cprev[11] = {0.0};

double dC[100] = {0.0};
double dfg[100] = {0.0};
double dig[100] = {0.0};
double dcg[100] = {0.0};
double dOg[100] = {0.0};

double Fg = 0.0;
double Ig = 0.0;
double Cg = 0.0;
double Og = 0.0;


double dUf[100] = {0.0};
double dUi[100] = {0.0};
double dUc[100] = {0.0};
double dUo[100] = {0.0};


//double Uf[100] = {0.0};
//double Ui[100] = {0.0};
//double Uc[100] = {0.0};
//double Uo[100] = {0.0};


//double Wf[60] = {0.0};
//double Wi[60] = {0.0};
//double Wc[60] = {0.0};
//double Wo[60] = {0.0};



//double W[60] = {0.0};

double Wfx = 0.0;
double Wcx = 0.0;
double Wix = 0.0;
double Wox = 0.0;
double hf = 0.0;
double hc = 0.0;
double hi = 0.0;
double ho = 0.0;

double loss[6] = {0.0};
double ddc = 0.0;

double X[6] = {0.0};

double X1[10] = {0.0};
double X2[10] = {0.0};
double X3[10] = {0.0};
double X4[10] = {0.0};
double X5[10] = {0.0};
double X6[10] = {0.0};
double out[6] = {0.0};
int iter = 0;
int f = 0.0;
int f2 = 0.0;


double tf = 0.0;
double ti = 0.0;
double tc = 0.0;
double tO = 0.0;



double Wi[2] = { 0.20922089, -0.42483646 };
double Wf[2] = { 0.7553301, 0.48214918 };
double Wc[2] = { 0.6274113, 0.6871158 };
double Wo[2] = { 0.35571808, -0.56450665 };
double Ui[1] = { 0.5652317 };
double Uf[1] = { -0.8502836 };
double Uc[1] = { -0.888813 };
double Uo[1] = { 0.526938 };
double bi[1] = { 0.8576933 };
double bf[1] = { 1.39106 };
double bc[1] = { -0.0018265678 };
double bo[1] = { 2.4720716 };
double W[1] = { 1.7440112 };
double b[1] = { 0.0031973927 };






// - E n d   o f   S T A T I C :   S e c t i o n -   

RAM_FUNCTIONS:

// -----------------------------------------------   
// This section should contain any 'c' functions     
// to be called from the RAM section (either         
// RAM_PASS1 or RAM_PASS2). Example:                 
//                                                   
// static double myFunction(double v1, double v2)    
// {                                                 
//     return(v1*v2);                                
// }                                                 
// -----------------------------------------------   

RAM:
N = numInputs;
nodes = nod;
Y = numOutputs;
T = Timesteps;

// -----------------------------------------------   
// Place C code here which computes constants        
// required for the CODE: section below.  The C      
// code here is executed once, prior to the start    
// of the simulation case.                           
// -----------------------------------------------   
//    dt= getTimeStep();                             


// ------------- End of RAM: Section -------------   

CODE_FUNCTIONS:

double test;

double sigmoid(double x) {
    return 1.0 / (1.0 + exp(-x));
}


static void ResetVar(){

	Wfx = 0.0;
	Wcx = 0.0;
	Wix = 0.0;
	Wox = 0.0;
	hf = 0.0;
	hc = 0.0;
	hi = 0.0;
	ho = 0.0;


}

static void ResetArrays(int nodes){

	for (k=0; k < nodes+1; k++){

hloss[k] = 0.0;
dhloss[k] = 0.0; 
h[k] = 0.0;
C[k] = 0.0;
Cprev[k] = 0.0;
}

}

static void getX(int N, int t){

X[0] = X1[t];

if(N>1){
X[1] = X2[t];
if(N>2){
	X[2] = X3[t];
	if(N>3){
		X[3] = X4[t];
		if(N>4){
			X[4] = X5[t];
			if(N>5){
				X[5] = X6[t];
			}
		}	
	}
}
}
}


static void FeedForward(int N, int Y, int T, int nodes){

  for (t = 0; t < T; t++) {
	getX(N,t);

	for (k=0; k < nodes; k++){
	for (i = 0; i < N; i++) { 
		iter = nodes*k+i; 
		Wfx += X[i]*Wf[iter];
		Wix += X[i]*Wi[iter];//add k term in brackets
		Wcx += X[i]*Wc[iter];
		Wox += X[i]*Wo[iter];
	}

	for (i = 0; i < nodes; i++) { 
		iter = nodes*k+i; 
		hf += h[i]*Uf[iter];
		hi += h[i]*Ui[iter];//add k term in brackets
		hc += h[i]*Uc[iter];
		ho += h[i]*Uo[iter];
	}

		C[k] = sigmoid(Wfx + hf +bf[k])* C[k] + sigmoid(Wix 				+ hi +bi[k]) * tanh(Wcx + hc + bc[k]);


		h_next[k] = sigmoid(Wox+ho+bo[k])*tanh(C[k]);
		ResetVar();
	}

for (k = 0; k < nodes; k++) {
			
		h[k] = h_next[k]; 
	}
	}
	for (k=0; k < nodes; k++){
		for (i=0; i < Y; i++){

			out[i] += h[k]*W[i*nodes + k];
		}
	} 

	for (y = 0; y < Y; y++) {

		out[y] = out[y] + b[y];
	}

}



static void UpdateTimestep(int T, int N){

for (i = 0; i < T-1; i++){

	X1[i] = X1[i+1];
	if (N>1){
		X2[i] = X2[i+1];
		if (N>2){
			X3[i] = X3[i+1];
			if (N>3){
				X4[i] = X4[i+1];
				if (N>4){
					X5[i] = X5[i+1];
					if (N>5){
						X6[i] = X6[i+1];
					}
				}
			}
		}
	}
}
}







static void getLoss(int Y, double Lrr){

loss[0] = L1;
b[0] = b[0] - Lrr * L1;
if(Y>1){
	loss[1] = L2;
	b[1] = b[1] - Lrr * L2;
	if(Y>2){
		loss[2] = L3;
		b[2] = b[2] - Lrr * L3;
		if(Y>3){
			loss[3] = L4;
			b[3] = b[3] - Lrr * L4;
			if(Y>4){
				loss[4] = L5;
				b[4] = b[4] - Lrr * L5;
				if(Y>5){
					loss[5] = L6;
					b[5] = b[5] - Lrr * L6;
				}
			}	
		}
	}
}


for (j = 0; j < nodes; j++) {

	for (y = 0; y < Y; y++) {
		
		Wloss[y*nodes+j] = loss[y] * h[j];
		hloss[j] += loss[y] * W[y*nodes+j]; 
		W[y*nodes+j] = W[y*nodes+j] - Wloss[y*nodes+j]*Lrr;   
	}
}
}

static void FFbackprop(int N, int Y, int nodes){

  for (t = 0; t < T; t++) {
	getX(N,t);

	for (k=0; k < nodes; k++){
	for (i = 0; i < N; i++) {
		iter = nodes*k+i; 
		Wfx += X[i]*Wf[iter];
		Wix += X[i]*Wi[iter];//add k term in brackets
		Wcx += X[i]*Wc[iter];
		Wox += X[i]*Wo[iter];
	}

	for (i = 0; i < nodes; i++) {
		iter = nodes*k + i;   
		hf += h[i]*Uf[iter];
		hi += h[i]*Ui[iter];//add k term in brackets
		hc += h[i]*Uc[iter];
		ho += h[i]*Uo[iter];
	}
		
		Fg = sigmoid(Wfx + hf +bf[k]);
		Ig = sigmoid(Wix + hi +bi[k]); 
		Cg = tanh(Wcx + hc + bc[k]);
		Og = sigmoid(Wox+ho+bo[k]);
		

		C[k]=Fg*Cprev[k]+Ig*Cg;

		h_next[k] = Og * tanh(C[k]);

		h_all[t*nodes+k] = Og * tanh(C[k]);

	
	ddc = Og*(1- tanh(C[k])*tanh(C[k]));
	dC[t*nodes+k] =  ddc;

	dOg[t*nodes+k] = tanh(C[k]) * Og * (1 - Og);
	
	dfg[t*nodes+k] = ddc * Cprev[k] * Fg * (1 - Fg);
	
	dig[t*nodes+k] = ddc * Cg * Ig *(1- Ig);
	
	dcg[t*nodes+k] = ddc * Ig * (1 - Cg*Cg);
		ResetVar();
		}

for (k = 0; k < nodes; k++) {
			
	h[k] = h_next[k]; 		
	Cprev[k] = C[k];
}

	}
	for (k = 0; k < nodes; k++) {
			

		for (i=0; i < Y; i++){

			out[i] += h[k]*W[i*nodes + k];
		}

	}

	for (y = 0; y < Y; y++) {

		out[y] = out[y] + b[y];
	}

}

static void ResetWeights(){

double dUf[100] = {0.0};
double dUi[100] = {0.0};
double dUc[100] = {0.0};
double dUo[100] = {0.0};
}



static void UpdateWeights(int N, int Y, int nodes, double Lrr){

for (t = T-1; t >= 0; t--) {
	getX(N,t);
	for (j=0; j < nodes; j++){
		f = nodes*t+j;
		tf = hloss[j]*dfg[f];
		ti = hloss[j]*dig[f];
		tc = hloss[j]*dcg[f];
		tO = hloss[j]*dOg[f];
		
		for (k=0; k < nodes; k++){
			f = j*nodes+k;

			dhloss[k]+= tO*Uo[f]+ti*Ui[f]+tc*Uc[f]+tf*Uf[f];
			
			f2 = t*nodes + k;
		
			dUf[f] += tf* h_all[f2];
			dUi[f] += ti* h_all[f2];
			dUc[f] += tc* h_all[f2];
			dUo[f] += tO* h_all[f2];
		}	

for (i=0; i < N; i++){
	f = nodes*j+i;
	Wf[f] -= Lrr * tf  * X[i]; 
	Wi[f] -= Lrr * ti * X[i];
	Wc[f] -= Lrr * tc * X[i];
	Wo[f] -= Lrr * tO * X[i];	
}



	bf[j] -= Lrr * tf;
	bi[j] -= Lrr * ti;
	bc[j] -= Lrr * tc; 
	bo[j] -= Lrr * tO;  

	}

	for (k=0; k < nodes; k++){

		hloss[k] = hloss[k]*dhloss[k];
		dhloss[k] = 0.0;
	}

	
}

for (i=0; i < nodes*nodes; i++){

Uf[i] = Uf[i] - Lrr * dUf[i];
dUf[i] = 0.0;
Ui[i] = Ui[i] - Lrr * dUi[i];
dUi[i] = 0.0;
Uc[i] = Uc[i] - Lrr * dUc[i];
dUc[i] = 0.0;
Uo[i] = Uo[i] - Lrr * dUo[i];
dUo[i] = 0.0;
}

//ResetWeights();
}





CODE:

UpdateTimestep(T, N);

X1[T-1] = x1;
X2[T-1] = x2;
X3[T-1] = x3;
X4[T-1] = x4;
X5[T-1] = x5;
X6[T-1] = x6;


if (Lr>0.0){


	getLoss(Y, Lr);
	UpdateWeights(N, Y, nodes, Lr);

	FFbackprop(N, Y, nodes);

}

else{

	FeedForward(N, Y, T, nodes);


}


foutput = out[0];
foutput2 = out[1];
foutput3 = out[2];
foutput4 = out[3];
foutput5 = out[4];
foutput6 = out[5];



out[0] = 0.0;
out[1] = 0.0;
out[2] = 0.0;
out[3] = 0.0;
out[4] = 0.0;
out[5] = 0.0;

ResetArrays(nodes);

// -----------------------------------------------   
// Place C code here which runs on the RTDS. The     
// code below is entered once each simulation        
// step.                                             
// -----------------------------------------------   


// ------------ End of CODE: Section -------------   
