VERSION:
???

// Include file below is generated by C-Builder    
// and contains the variables declared as -        
// PARAMETERS, INPUTS, OUTPUTS . . .               
#include "lstmtest5.h"

STATIC:

// ----------------------------------------------- 
// Variables declared here may be used in both the 
// RAM: and CODE: sections below.                  
// ----------------------------------------------- 


double dt;

int firstTimeStep = 1;

int OverrunFlag = 0;


// - E n d   o f   S T A T I C :   S e c t i o n - 

RAM_FUNCTIONS:

// ----------------------------------------------- 
// This section should contain any 'c' functions   
// to be called from the RAM section (either       
// RAM_PASS1 or RAM_PASS2). Example:               
//                                                 
// static double myFunction(double v1, double v2)  
// {                                               
//     return(v1*v2);                              
// }                                               
// ----------------------------------------------- 


RAM:

// ----------------------------------------------- 
// Place C code here which computes constants      
// required for the CODE: section below.  The C    
// code here is executed once, prior to the start  
// of the simulation case.                         
// ----------------------------------------------- 


dt= getTimeStep();


// ---- E n d   o f   R A M :   S e c t i o n ---- 

CODE_FUNCTIONS:

// ----------------------------------------------- 
//                                                 
//                                                 
//                                                 
// ----------------------------------------------- 

#include "LSTMtestfive.h"
#include <math.h>
#include "rtwtypes.h"



D_Work_LSTMtestfive_T LSTMtestfive_DWork;

ExternalInputs_LSTMtestfive_T LSTMtestfive_U;

ExternalOutputs_LSTMtestfive_T LSTMtestfive_Y;

static RT_MODEL_LSTMtestfive_T LSTMtestfive_M_;

RT_MODEL_LSTMtestfive_T *LSTMtestfive_M;

RT_MODEL_LSTMtestfive_T *LSTMtestfive_M;

// weights and biases initialization

real_T Wi[2] = {0.47616756, -0.32330066};
real_T Wf[2] = {-0.05271522, 0.4497215};
real_T Wo[2] = {0.38727042, -0.836893};
real_T Wc[2] = {-0.4431671, -0.88845116};

double Ui = -0.34895834;
double Uf = 0.5757532;
double Uo = -0.9445941;
double Uc = -0.9593414;

double bi = 1.1773931;
double bf = 1.6209718;
double bo = 2.7263885;
double bc = -0.08978768;

double W = -1.3497251;
double b = -0.10075802; 


static void FFbackpropagation(real_T X[5], real_T XX[5], double label, double Lrr){

int32_T t;
real_T XX_0;
real_T X_0;
real_T I[5];
real_T f[5];
real_T o[5];
real_T c[5];
real_T h1[6] = {0.0,0.0,0.0,0.0,0.0,0.0};
real_T C1[6] = {0.0,0.0,0.0,0.0,0.0,0.0};
double dloss;
double hloss;
real_T dC[5];


real_T II[5];
real_T ff[5];
real_T oo[5];
real_T cc[5];


real_T df[5];
real_T di[5];
real_T dc[5];
real_T doo[5];

double dUi = 0.0;
double dUf = 0.0;
double dUc = 0.0;
double dUo = 0.0;
double dWi[2] = {0.0,0.0};
double dWf[2] = {0.0,0.0};
double dWc[2] = {0.0,0.0};
double dWo[2] = {0.0,0.0};

double dbi = 0.0;
double dbf = 0.0;
double dbc = 0.0;
double dbo = 0.0;


for(t = 0; t < 5; t++) {
    X_0 = X[4-t];
    XX_0 = XX[4-t];
	
	ff[t] = ((Wf[0] * X_0 + Wf[1] * XX_0) + h1[t] * Uf)  + bf;
	II[t] = ((Wi[0]* X_0 + Wi[1]* XX_0) + h1[t]  * Ui) + bi;

	cc[t] = ((Wc[0]* X_0 + Wc[1] * XX_0) + h1[t]  * Uc) + bc;
	oo[t] = ((Wo[0]* X_0 + Wo[1] * XX_0) + h1[t] *Uo) + bo;

    f[t] = 1.0 / (exp(-(ff[t])) + 1.0); 
    I[t] = 1.0 / (exp(-(II[t])) + 1.0); 
    c[t] = tanh(cc[t]);
    o[t] = 1.0 / (exp(-(oo[t])) + 1.0);
 
    C1[t+1] = f[t]* C1[t] + I[t] * c[t];

    h1[t+1] = o[t] * tanh(C1[t+1]);

di[t] = 1 - I[t];
df[t] = 1- f[t];
dc[t] = 1 - c[t] * c[t];
doo[t] = 1 - o[t];

dC[t] = o[t] * (1 - tanh(C1[t+1]) * tanh(C1[t+1]));
  
  }

LSTMtestfive_Y.y_hat = h1[5] * W+ b;

dloss = 2 * (LSTMtestfive_Y.y_hat - label); 

// Dense layer losses for weight w and bias b
double Wloss = dloss * h1[5];


hloss = dloss * W;

dUf += hloss * dC[4] * C1[5] * df[4] * h1[5]; 
dUi += hloss * dC[4] * c[4] * di[4] * h1[5];
dUc += hloss * dC[4] * I[4] * dc[4] * h1[5];
dUo += hloss * tanh(C1[5]) * doo[4] * h1[5];	

dWf[0] += hloss * dC[4] * C1[5] * df[4] * X[4]; 
dWi[0] += hloss * dC[4] * c[4] * di[4] * X[4];
dWc[0] += hloss * dC[4] * I[4] * dc[4] * X[4];
dWo[0] += hloss * tanh(C1[5]) * doo[4] * X[4];	


dWf[1] += hloss * dC[4] * C1[5] * df[4] * XX[4]; 
dWi[1] += hloss * dC[4] * c[4] * di[4] * XX[4];
dWc[1] += hloss * dC[4] * I[4] * dc[4] * XX[4];
dWo[1] += hloss * tanh(C1[5]) * doo[4] * XX[4];


dbf += hloss * dC[4] * C1[5] * df[4]; 
dbi += hloss * dC[4] * c[4] * di[4];
dbc += hloss * dC[4] * I[4] * dc[4];
dbo += hloss * tanh(C1[5]) * doo[4];

// here compute losses for last timestep before the loop

for(t = 0; t < 4; t++) {
    hloss = hloss * (dC[4-t] * (df[4-t] * Uf + di[4-t] * Ui + dc[4-t] * Uc) + tanh(C1[5-t])*doo[4-t]*Uo);


dUf += hloss * dC[3-t] * C1[3 - t] * df[3-t] * h1[3-t]; 
dUi += hloss * dC[3-t] * c[3-t] * di[3-t] * h1[3-t];
dUc += hloss * dC[3-t] * I[3-t] * dc[3-t] * h1[3-t];
dUo += hloss * tanh(C1[3-t]) * doo[3-t] * h1[3-t];	

dWf[0] += hloss * dC[3-t] * C1[3 - t] * df[3-t] * X[3-t]; 
dWi[0] += hloss * dC[3-t] * c[3-t] * di[3-t] * X[3-t];
dWc[0] += hloss * dC[3-t] * I[3-t] * dc[3-t] * X[3-t];
dWo[0] += hloss * tanh(C1[3-t]) * doo[3-t] * X[3-t];	


dWf[1] += hloss * dC[3-t] * C1[3 - t] * df[3-t] * XX[3-t]; 
dWi[1] += hloss * dC[3-t] * c[3-t] * di[3-t] * XX[3-t];
dWc[1] += hloss * dC[3-t] * I[3-t] * dc[3-t] * XX[3-t];
dWo[1] += hloss * tanh(C1[3-t]) * doo[3-t] * XX[3-t];


dbf += hloss * dC[3-t] * C1[3 - t] * df[3-t]; 
dbi += hloss * dC[3-t] * c[3-t] * di[3-t];
dbc += hloss * dC[3-t] * I[3-t] * dc[3-t];
dbo += hloss * tanh(C1[3-t]) * doo[3-t];

  }
 
Uf = Uf - Lrr * dUf;
Ui = Ui - Lrr * dUi;
Uc = Uc - Lrr * dUc;
Uo = Uo - Lrr * dUo;

Wf[0] = Wf[0] - Lrr * dWf[0];
Wf[1] = Wf[1] - Lrr * dWf[1];

Wi[0] = Wi[0] - Lrr * dWi[0];
Wi[1] = Wi[1] - Lrr * dWi[1];

Wc[0] = Wc[0] - Lrr * dWc[0];
Wc[1] = Wc[1] - Lrr * dWc[1];

Wo[0] = Wo[0] - Lrr * dWo[0];
Wo[1] = Wo[1] - Lrr * dWo[1];

bf = bf - Lrr * dbf;
bi = bi - Lrr * dbi;
bc = bc - Lrr * dbc;
bo = bo - Lrr * dbo;

W = W - Lrr * Wloss;
b = b - Lrr * dloss;
}

real_T prev = 0.0;

double lim = 1.0;
void LSTMtestfive_step(void)
{
  real_T X[5];
  real_T XX[5];

double Lrr = LSTMtestfive_U.Lr; 


double label = LSTMtestfive_U.l;



  X[0] = LSTMtestfive_U.x1;
  X[1] = LSTMtestfive_DWork.Delay_DSTATE;
  X[2] = LSTMtestfive_DWork.Delay1_DSTATE[0U];
  X[3] = LSTMtestfive_DWork.Delay2_DSTATE[0U];
  X[4] = LSTMtestfive_DWork.Delay3_DSTATE[0U];
  XX[0] = LSTMtestfive_U.x2;
  XX[1] = LSTMtestfive_DWork.Delay4_DSTATE;
  XX[2] = LSTMtestfive_DWork.Delay5_DSTATE[0U];
  XX[3] = LSTMtestfive_DWork.Delay6_DSTATE[0U];
  XX[4] = LSTMtestfive_DWork.Delay7_DSTATE[0U];


if (Lrr > 0.0){

FFbackpropagation(X, XX, label, Lrr);

}

else {

  real_T C1 = 0.0;
  real_T XX_0;
  real_T X_0;
  real_T h1 = 0.0;
  int32_T t;

  for (t = 0; t < 5; t++) {
    X_0 = X[4-t];
    XX_0 = XX[4-t];
    C1 = 1.0 / (exp(-(((Wf[0] * X_0 + Wf[1] * XX_0) + h1 * Uf)
                      + bf)) + 1.0) * C1 + 1.0 / (exp(-(((Wi[0]*
      X_0 + Wi[1]* XX_0) + h1 * Ui) + bi)) + 1.0) * tanh
      (((Wc[0]* X_0 + Wc[1] * XX_0) + h1 * Uc) + bc);
    h1 = 1.0 / (exp(-(((Wo[0]* X_0 + Wo[1] * XX_0) + h1 *
                       Uo) + bo)) + 1.0) * tanh(C1);
  }

  LSTMtestfive_Y.y_hat = h1 * W+ b;

}
  
if (fabs(LSTMtestfive_Y.y_hat - prev )> lim){

		if (LSTMtestfive_Y.y_hat - prev > 0){
			LSTMtestfive_Y.y_hat = prev + lim;
		}
		else{
			LSTMtestfive_Y.y_hat = prev - lim;
			}
		}
   
	prev = LSTMtestfive_Y.y_hat; 


  LSTMtestfive_DWork.Delay_DSTATE = LSTMtestfive_U.x1;

  


  LSTMtestfive_DWork.Delay1_DSTATE[0] = LSTMtestfive_DWork.Delay1_DSTATE[1];
  LSTMtestfive_DWork.Delay1_DSTATE[1] = LSTMtestfive_U.x1;

  


  LSTMtestfive_DWork.Delay2_DSTATE[0] = LSTMtestfive_DWork.Delay2_DSTATE[1];
  LSTMtestfive_DWork.Delay2_DSTATE[1] = LSTMtestfive_DWork.Delay2_DSTATE[2];
  LSTMtestfive_DWork.Delay2_DSTATE[2] = LSTMtestfive_U.x1;

  


  LSTMtestfive_DWork.Delay3_DSTATE[0] = LSTMtestfive_DWork.Delay3_DSTATE[1];
  LSTMtestfive_DWork.Delay3_DSTATE[1] = LSTMtestfive_DWork.Delay3_DSTATE[2];
  LSTMtestfive_DWork.Delay3_DSTATE[2] = LSTMtestfive_DWork.Delay3_DSTATE[3];
  LSTMtestfive_DWork.Delay3_DSTATE[3] = LSTMtestfive_U.x1;

  


  LSTMtestfive_DWork.Delay4_DSTATE = LSTMtestfive_U.x2;

  


  LSTMtestfive_DWork.Delay5_DSTATE[0] = LSTMtestfive_DWork.Delay5_DSTATE[1];
  LSTMtestfive_DWork.Delay5_DSTATE[1] = LSTMtestfive_U.x2;

  


  LSTMtestfive_DWork.Delay6_DSTATE[0] = LSTMtestfive_DWork.Delay6_DSTATE[1];
  LSTMtestfive_DWork.Delay6_DSTATE[1] = LSTMtestfive_DWork.Delay6_DSTATE[2];
  LSTMtestfive_DWork.Delay6_DSTATE[2] = LSTMtestfive_U.x2;

  


  LSTMtestfive_DWork.Delay7_DSTATE[0] = LSTMtestfive_DWork.Delay7_DSTATE[1];
  LSTMtestfive_DWork.Delay7_DSTATE[1] = LSTMtestfive_DWork.Delay7_DSTATE[2];
  LSTMtestfive_DWork.Delay7_DSTATE[2] = LSTMtestfive_DWork.Delay7_DSTATE[3];
  LSTMtestfive_DWork.Delay7_DSTATE[3] = LSTMtestfive_U.x2;
}


void LSTMtestfive_terminate(void)
{
  
}


void rt_OneStep(void)
{
	
	
	
	
	if (OverrunFlag) {
		rtmSetErrorStatus(LSTMtestfive_M, "Overrun");
		return;
		}
	
	OverrunFlag = true;
	
	
	
	
	
	
	LSTMtestfive_step();
	
	
	
	
	OverrunFlag = false;
	
	
	
	
	}



void LSTMtestfive_initialize(void)
{
  
}


CODE:

// ----------------------------------------------- 
// Place C code here which runs on the RTDS. The   
// code below is entered once each simulation      
// step.                                           
// ----------------------------------------------- 


LSTMtestfive_U.Lr = Lr;
LSTMtestfive_U.l = l;
LSTMtestfive_U.x2 = x2;
LSTMtestfive_U.x1 = x1;

if (firstTimeStep == 1)
{
	LSTMtestfive_M =  &LSTMtestfive_M_;
	LSTMtestfive_M =  &LSTMtestfive_M_;
	LSTMtestfive_initialize();
	firstTimeStep = 0;
}
else
{
	rt_OneStep();
}

y_hat = LSTMtestfive_Y.y_hat;

// ---- E n d   o f   C O D E :  S e c t i o n --- 
