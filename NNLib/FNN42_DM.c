#include <stdio.h>
#include <string.h>

#include <cbuilder_ctrl_commonRW.h>

#include <math.h>

static char* checkSumC_FNN42_ba4a7cff2c7d773e896526424c9acd4c;
extern void* rpcControlStructurePointer;
extern FILE* mapFile;


// now here are the lines from the GLOBAL section, typically #defines... 
// ======================================================================
// Include file below is generated by C-Builder    

// and contains the variables declared as -        

// PARAMETERS, INPUTS, OUTPUTS . . .               

#define PI        3.1415926535897932384626433832795   // definition of PI                 

#define TWOPI     6.283185307179586476925286766559    // definition of 2.0*PI             

#define E         2.71828182845904523536028747135266  // definition of E                  

#define EINV      0.36787944117144232159552377016147  // definition of E Inverse (1/E)    

#define RT2       1.4142135623730950488016887242097   // definition of square root 2.0    

#define RT3       1.7320508075688772935274463415059   // definition of square root 3.0    

#define INV_ROOT2 0.70710678118654752440084436210485                                      

// finished the GLOBAL section (#defines)
// ======================================


// now here are the static variables the user has defined... 
//===========================================================


// ----------------------------------------------- 

// Variables declared here may be used in both the 

// RAM: and CODE: sections below.                  

// ----------------------------------------------- 





static double dt;



static int firstTimeStep = 1;



static int OverrunFlag = 0;





// - E n d   o f   S T A T I C :   S e c t i o n - 



// end the user defined STATIC declarations ... 
//===========================================================

// declare the Parameters so that the user's code can reference them
// =================================================================
static   int numInputs;  //Number of Inputs:

static   int numOutputs; //Number of Outputs:


// end Parameter declarations 
// ========================== 


static void initializeParameterDataRW(void *this_)
{
    // initialize the Parameter values so that the user's code can reference them*/
    // ===========================================================================
    numInputs = getIntParameter(this_,"numInputs");
    numOutputs = getIntParameter(this_,"numOutputs");

    // end initializing Parameters 
    // =========================== 

}


static void saveInstance (void *this_, int R_proc1);

static void loadInstance (void *this_, int R_proc1);

/* copy the lines of code from the RAM_FUNCTIONS section */


// ----------------------------------------------- 

// This section should contain any 'c' functions   

// to be called from the RAM section (either       

// RAM_PASS1 or RAM_PASS2). Example:               

//                                                 

// static double myFunction(double v1, double v2)  

// {                                               

//     return(v1*v2);                              

// }                                               

// ----------------------------------------------- 






static void initializeLocalDataRW(void *this_, int R_proc1)
{
    // initialize the local data based on a special section in the user's c code
    // ===========================================================================
    rpcControlStructurePointer = this_;

    // end initializing local data 
    // =========================== 

}


static void userSuppliedRamPass0Code(void* this_)
{
    rpcControlStructurePointer = this_;

    // copy the lines of code from the RAM_PASS0 section 
}

static void userSuppliedRamPass1Code(void* this_, int R_proc1)
{
    rpcControlStructurePointer = this_;
    void* comp = this_; //for psys component calls that used 'comp'

    // declare the variables the user has supplied in the RAM_DECLARATIONS section 

    // copy the lines of code from the RAM_PASS1 section 
}
static void* mallocInstancePointer (void *this_, int R_proc1)
{
  //  FILE *debugFile;
  //  debugFile = fopen("C:\\RTDS_USER\\testdebug.txt","a");
  //  fprintf(debugFile,"dbgcmb - entering mallocInstancePointer function for component FNN42 R_proc1 = %i \n",R_proc1);
  //  fclose(debugFile);

    rpcControlStructurePointer = this_;
    void* staticInstancePointer = NULL; 
    int sizeOfStaticSection = 16;
    int sizeOfLocalStaticSection = 0;
    staticInstancePointer = (void*)malloc(sizeOfStaticSection+sizeOfLocalStaticSection);
    return(staticInstancePointer);
}


static void saveInstance (void *this_, int R_proc1)
{
    rpcControlStructurePointer = this_;
    unsigned char* staticVariablesInstancePtr = getLocalStaticInstancePointer_RW(this_);
   // unsigned char* staticVariablesInstancePtr = NULL;
    if (staticVariablesInstancePtr == NULL)
    {
        staticVariablesInstancePtr = mallocInstancePointer (this_,R_proc1);
        setLocalStaticInstancePointer_RW(this_,staticVariablesInstancePtr);
    }

    unsigned char* tempPtr = staticVariablesInstancePtr;
    int index = 0;
    memcpy(tempPtr, (unsigned char*)&dt,sizeof(dt));
    tempPtr += sizeof(dt);
    memcpy(tempPtr, (unsigned char*)&firstTimeStep,sizeof(firstTimeStep));
    tempPtr += sizeof(firstTimeStep);
    memcpy(tempPtr, (unsigned char*)&OverrunFlag,sizeof(OverrunFlag));
    tempPtr += sizeof(OverrunFlag);
}

static void loadInstance (void *this_, int R_proc1)
{
    rpcControlStructurePointer = this_;
    unsigned char* staticVariablesInstancePtr = getLocalStaticInstancePointer_RW(this_);
    unsigned char* tempPtr = staticVariablesInstancePtr;
    int index = 0;
    if (staticVariablesInstancePtr == NULL)
        return;
    memcpy((unsigned char*)&dt, tempPtr, sizeof(dt));
    tempPtr += sizeof(dt);
    memcpy((unsigned char*)&firstTimeStep, tempPtr, sizeof(firstTimeStep));
    tempPtr += sizeof(firstTimeStep);
    memcpy((unsigned char*)&OverrunFlag, tempPtr, sizeof(OverrunFlag));
    tempPtr += sizeof(OverrunFlag);
}

DllExport int FNN42_GET_NUM_NAMED_INPUTS(void *this_)
{
    //This comes from CmodelCompiler.createCtlExtraIOCode
    //int cntl_idx;
    int numNamedInputs = 0;
    //rpcControlStructurePointer = this_;
    //cntl_idx = 0;
    numNamedInputs = 0;
    return(numNamedInputs);
}
DllExport int FNN42_GET_NUM_NAMED_OUTPUTS(void *this_)
{
    //This comes from CmodelCompiler.createCtlExtraIOCode
    //int cntl_idx;
    //rpcControlStructurePointer = this_;
    int numNamedOutputs = 0;
    //cntl_idx = 0;
    numNamedOutputs = 0;
    //this code from CmodelCompiler.createCtlExtraIOCode
    return(numNamedOutputs);
}
DllExport int FNN42_ADD_EXTRA_IO(void *this_, int R_proc1)
{
    //This comes from CmodelCompiler.createCtlExtraIOCode
    int cntl_idx;
    rpcControlStructurePointer = this_;
    initializeParameterDataRW(this_);

    initializeLocalDataRW(this_, R_proc1);

    saveInstance(this_,R_proc1);  //new!
}
DllExport int FNN42_GET_FLAG_PARTICIPATION(void *this_)
{
    //This comes from CmodelCompiler.createFlagParticipationCode
    int flags;
    flags = 0;
    flags = flags | 0x04;
    return(flags);
}

static void userSuppliedRamCode(int R_proc1)
{
   ramPassNumber = 2;


    /***** declare the variables the user has supplied in the RAM_DECLARATIONS section */

    /* copy the lines of code from the RAM section */
// ----------------------------------------------- 

// Place C code here which computes constants      

// required for the CODE: section below.  The C    

// code here is executed once, prior to the start  

// of the simulation case.                         

// ----------------------------------------------- 

dt= getTimeStep();

// ---- E n d   o f   R A M :   S e c t i o n ---- 

}
DllExport void FNN42_DM_RW (void *this_, int R_proc1,  int *wdadr_ptr1)
{
    rpcControlStructurePointer = this_;
    loadInstance(this_, R_proc1);  //new!
    initializeParameterDataRW(this_);
 //   initializeLocalDataRW(this_, R_proc1);    //<<<<<<<<<<<<<< TO-DO, change to this!
    int __inDMCode = 1;
    ramPassNumber = 1;
    FILE* signatureFile;
    //re-execute the Ram Pass1 code. This is necessary because
    //if more than one instance of a particular model is used in 
    //a case, all instances will share the same static variables.
    //This means the variables will have to be re-calculated before 
    //they are written out to data memory.

    //userSuppliedRamPass1Code(this_,R_proc1);  //<<<<<<<<<<<<<< TO-DO, change to this!
    //now call the Ram Pass2 code 

    ramPassNumber = 2;
    userSuppliedRamCode(R_proc1);
    double         __fdata=0;
    int            __idata=0;
    unsigned char *__bdata;
    char          *__pattern;
    int            __loopindex=0;
    char           __cdata[12]; //this is sized to match the Cdta entry in rt_ctl_data_t structure in rtdspc
    unsigned char* __blob;
    char*          __blob2;
    char          *__hexstring;
    char          *__pos;


    //1) storing variable b
    //----------------
    storeCtlVariableInDM_RW(this_,R_proc1,wdadr_ptr1,"b",1,1);

    //1) storing variable iqL
    //----------------
    storeCtlVariableInDM_RW(this_,R_proc1,wdadr_ptr1,"iqL",1,1);

    //1) storing variable idL
    //----------------
    storeCtlVariableInDM_RW(this_,R_proc1,wdadr_ptr1,"idL",1,1);

    //1) storing variable iq
    //----------------
    storeCtlVariableInDM_RW(this_,R_proc1,wdadr_ptr1,"iq",1,1);

    //1) storing variable id
    //----------------
    storeCtlVariableInDM_RW(this_,R_proc1,wdadr_ptr1,"id",1,1);

    //1) storing variable Lr
    //----------------
    storeCtlVariableInDM_RW(this_,R_proc1,wdadr_ptr1,"Lr",1,1);

    //1) storing variable u2
    //----------------
    storeCtlVariableInDM_RW(this_,R_proc1,wdadr_ptr1,"u2",1,1);

    //1) storing variable u1
    //----------------
    storeCtlVariableInDM_RW(this_,R_proc1,wdadr_ptr1,"u1",1,1);

    //1) storing variable L
    //----------------
    storeCtlVariableInDM_RW(this_,R_proc1,wdadr_ptr1,"L",1,1);

    //1) storing variable x4
    //----------------
    storeCtlVariableInDM_RW(this_,R_proc1,wdadr_ptr1,"x4",1,1);

    //1) storing variable x3
    //----------------
    storeCtlVariableInDM_RW(this_,R_proc1,wdadr_ptr1,"x3",1,1);

    //1) storing variable x2
    //----------------
    storeCtlVariableInDM_RW(this_,R_proc1,wdadr_ptr1,"x2",1,1);

    //1) storing variable x1
    //----------------
    storeCtlVariableInDM_RW(this_,R_proc1,wdadr_ptr1,"x1",1,1);

    //2) storing variable d
    //----------------
    storeCtlVariableInDM_RW(this_,R_proc1,wdadr_ptr1,"d",0,1);

    //2) storing variable q
    //----------------
    storeCtlVariableInDM_RW(this_,R_proc1,wdadr_ptr1,"q",0,1);

    //3) storing variable numInputs
    //----------------
    storeCtlVariableInDM_RW(this_,R_proc1,wdadr_ptr1,"numInputs",1,1);

    //3) storing variable numOutputs
    //----------------
    storeCtlVariableInDM_RW(this_,R_proc1,wdadr_ptr1,"numOutputs",1,1);
    //increasing wdadr_ptr1 in order to align variable dt with alignment requirement of 8
    *wdadr_ptr1 += 1;

    //3) storing variable dt
    //----------------
     __bdata = (unsigned char*) malloc(8);
     endianSwapRW((unsigned char *)(&dt),2,"Dd",__bdata);
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,2,"dt");
    free(__bdata); //2
    //----------------


    //3) storing variable firstTimeStep
    //----------------
     __bdata = (unsigned char*) malloc(4);
     endianSwapRW((unsigned char *)(&firstTimeStep),1,"i",__bdata);
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,1,"firstTimeStep");
    free(__bdata); //2
    //----------------


    //3) storing variable OverrunFlag
    //----------------
     __bdata = (unsigned char*) malloc(4);
     endianSwapRW((unsigned char *)(&OverrunFlag),1,"i",__bdata);
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,1,"OverrunFlag");
    free(__bdata); //2
    //----------------


    //3) storing variable backprop11_M
    //----------------

    //4) storing variable backprop11_M: allocating blob of size 4 plus 3 because we need an extra 3 bytes to fill out the");
    //last 'unsigned char' to be a full 'int' in size, so that it sscanf properly with %2x. (otherwise it's nasty!!!)");
    __bdata = (unsigned char*)malloc(4+3);
    for (__loopindex=0; __loopindex<4; __loopindex++)
    {
        __bdata[__loopindex] = 0;
    }
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,1,"backprop11_M");
    free(__bdata);  //1
    //increasing wdadr_ptr1 in order to align variable backprop11_Y with alignment requirement of 8
    *wdadr_ptr1 += 1;

    //3) storing variable backprop11_Y
    //----------------

    //4) storing variable backprop11_Y: allocating blob of size 16 plus 3 because we need an extra 3 bytes to fill out the");
    //last 'unsigned char' to be a full 'int' in size, so that it sscanf properly with %2x. (otherwise it's nasty!!!)");
    __bdata = (unsigned char*)malloc(16+3);
    for (__loopindex=0; __loopindex<16; __loopindex++)
    {
        __bdata[__loopindex] = 0;
    }
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,4,"backprop11_Y");
    free(__bdata);  //1

    //3) storing variable backprop11_U
    //----------------

    //4) storing variable backprop11_U: allocating blob of size 104 plus 3 because we need an extra 3 bytes to fill out the");
    //last 'unsigned char' to be a full 'int' in size, so that it sscanf properly with %2x. (otherwise it's nasty!!!)");
    __bdata = (unsigned char*)malloc(104+3);
    for (__loopindex=0; __loopindex<104; __loopindex++)
    {
        __bdata[__loopindex] = 0;
    }
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,26,"backprop11_U");
    free(__bdata);  //1

    //3) storing variable iqloss
    //----------------

    //4) storing variable iqloss: allocating blob of size 8 plus 3 because we need an extra 3 bytes to fill out the");
    //last 'unsigned char' to be a full 'int' in size, so that it sscanf properly with %2x. (otherwise it's nasty!!!)");
    __bdata = (unsigned char*)malloc(8+3);
    __hexstring = "0000000000000000";
    __pos = __hexstring;
    for (__loopindex=0; __loopindex<8; __loopindex++)
    {
        sscanf(__pos,"%2x",&__bdata[__loopindex]);
        __pos += 2;
    }
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,2,"iqloss");
    free(__bdata);  //1

    //3) storing variable idloss
    //----------------

    //4) storing variable idloss: allocating blob of size 8 plus 3 because we need an extra 3 bytes to fill out the");
    //last 'unsigned char' to be a full 'int' in size, so that it sscanf properly with %2x. (otherwise it's nasty!!!)");
    __bdata = (unsigned char*)malloc(8+3);
    __hexstring = "0000000000000000";
    __pos = __hexstring;
    for (__loopindex=0; __loopindex<8; __loopindex++)
    {
        sscanf(__pos,"%2x",&__bdata[__loopindex]);
        __pos += 2;
    }
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,2,"idloss");
    free(__bdata);  //1

    //3) storing variable bn
    //----------------

    //4) storing variable bn: allocating blob of size 4 plus 3 because we need an extra 3 bytes to fill out the");
    //last 'unsigned char' to be a full 'int' in size, so that it sscanf properly with %2x. (otherwise it's nasty!!!)");
    __bdata = (unsigned char*)malloc(4+3);
    __hexstring = "00000000";
    __pos = __hexstring;
    for (__loopindex=0; __loopindex<4; __loopindex++)
    {
        sscanf(__pos,"%2x",&__bdata[__loopindex]);
        __pos += 2;
    }
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,1,"bn");
    free(__bdata);  //1
    //increasing wdadr_ptr1 in order to align variable b32 with alignment requirement of 8
    *wdadr_ptr1 += 1;

    //3) storing variable b32
    //----------------

    //4) storing variable b32: allocating blob of size 8 plus 3 because we need an extra 3 bytes to fill out the");
    //last 'unsigned char' to be a full 'int' in size, so that it sscanf properly with %2x. (otherwise it's nasty!!!)");
    __bdata = (unsigned char*)malloc(8+3);
    __hexstring = "0000000000000000";
    __pos = __hexstring;
    for (__loopindex=0; __loopindex<8; __loopindex++)
    {
        sscanf(__pos,"%2x",&__bdata[__loopindex]);
        __pos += 2;
    }
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,2,"b32");
    free(__bdata);  //1

    //3) storing variable b31
    //----------------

    //4) storing variable b31: allocating blob of size 8 plus 3 because we need an extra 3 bytes to fill out the");
    //last 'unsigned char' to be a full 'int' in size, so that it sscanf properly with %2x. (otherwise it's nasty!!!)");
    __bdata = (unsigned char*)malloc(8+3);
    __hexstring = "0000000000000000";
    __pos = __hexstring;
    for (__loopindex=0; __loopindex<8; __loopindex++)
    {
        sscanf(__pos,"%2x",&__bdata[__loopindex]);
        __pos += 2;
    }
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,2,"b31");
    free(__bdata);  //1

    //3) storing variable b2
    //----------------

    //4) storing variable b2: allocating blob of size 96 plus 3 because we need an extra 3 bytes to fill out the");
    //last 'unsigned char' to be a full 'int' in size, so that it sscanf properly with %2x. (otherwise it's nasty!!!)");
    __bdata = (unsigned char*)malloc(96+3);
    __hexstring = "000000000000000080000000000000008000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000080000000000000008000000000000000";
    __pos = __hexstring;
    for (__loopindex=0; __loopindex<96; __loopindex++)
    {
        sscanf(__pos,"%2x",&__bdata[__loopindex]);
        __pos += 2;
    }
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,24,"b2");
    free(__bdata);  //1

    //3) storing variable b1
    //----------------

    //4) storing variable b1: allocating blob of size 96 plus 3 because we need an extra 3 bytes to fill out the");
    //last 'unsigned char' to be a full 'int' in size, so that it sscanf properly with %2x. (otherwise it's nasty!!!)");
    __bdata = (unsigned char*)malloc(96+3);
    __hexstring = "000000000000000080000000000000000000000000000000000000000000000080000000000000000000000000000000800000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000";
    __pos = __hexstring;
    for (__loopindex=0; __loopindex<96; __loopindex++)
    {
        sscanf(__pos,"%2x",&__bdata[__loopindex]);
        __pos += 2;
    }
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,24,"b1");
    free(__bdata);  //1

    //3) storing variable W3
    //----------------

    //4) storing variable W3: allocating blob of size 192 plus 3 because we need an extra 3 bytes to fill out the");
    //last 'unsigned char' to be a full 'int' in size, so that it sscanf properly with %2x. (otherwise it's nasty!!!)");
    __bdata = (unsigned char*)malloc(192+3);
    __hexstring = "3fc353d884bbe6f6bfe427606169a7643fb262c6f49b9dd6bfbd5ddafc905edd3fe2aa1f8e3ac0c63fe1e45eff94cb29bfbf1fe7fcd3fb95bfe2469c66d373b03fa2d7f1eef038373f903a3c3bf07117bfc4fb1306420e6dbfc722c47b19a6c53fc353d884bbe6f6bfe427606169a7643fb262c6f49b9dd6bfbd5ddafc905edd3fe2aa1f8e3ac0c63fe1e45eff94cb29bfbf1fe7fcd3fb95bfe2469c66d373b03fa2d7f1eef038373f903a3c3bf07117bfc4fb1306420e6dbfc722c47b19a6c5";
    __pos = __hexstring;
    for (__loopindex=0; __loopindex<192; __loopindex++)
    {
        sscanf(__pos,"%2x",&__bdata[__loopindex]);
        __pos += 2;
    }
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,48,"W3");
    free(__bdata);  //1

    //3) storing variable W2
    //----------------

    //4) storing variable W2: allocating blob of size 1152 plus 3 because we need an extra 3 bytes to fill out the");
    //last 'unsigned char' to be a full 'int' in size, so that it sscanf properly with %2x. (otherwise it's nasty!!!)");
    __bdata = (unsigned char*)malloc(1152+3);
    __hexstring = "bfde61c9ff3d0c7bbfd75d588074af7fbfd12ea17e1482ef3fd0f0198308de763fd5a48af9c3a5ddbfde136c83e1cc63bfd176e67bca7bba3fd350717cc4f796bfb6403c053ed92f3fc53dc2026e6f493fd12d8e8390eea53fb1ae5bf370d0783f84558fa980c25d3fd8494771ae9905bfc47adf03dc02a0bfa0ac3fe47184273fd5d27fff94a036bfc21265076baf26bfc3fa0600751adfbfd1978c791fa68ebfd7f9797e1b38ec3faffa541987bb76bfc85a30f8f142f9bfd04fea8e7eb364bfbe484ffaea168a3fbfeeaff67d4a59bfd6949e8815e3973fd4359a812026103fda70b50961a892bfa5888fdc009c5dbfdd71688d88135f3fb686e81120e4a7bfd325540235ba4c3fc5375af599f58abfdc59fc806ea54f3fdc16fa82e87d2cbfafc5fc2326a0a9bfa15e9c17a334ce3fc23ca9ff6d5dfcbf94127fdf5e49e2bfd549bd02aa5452bfcde2f90915d351bf89e7affd0853e1bfca762d02ed70303fbe05be0508d3633fc21a740a12fe5f3fd2d5eb0399928ebfdac0aa7f9aead23fc964330565f0753fc6ade1fb0747c8bfdde76701ecbf31bfc445db009729a8bfd398bdfc7a6475bfcbbddef33ffe1dbfce2424f85cf376bfdca3fb87cb3afcbfde8e4bf31d996ebfcc3eb1003d92883fcb4dd8fbda2b853fc35fdb06f740133fc4b6fafe6372c13fb355b00aca336a3fd5f6c27f160aae3fdac0f57e1be4b83fc0c407007a4e50bfd246a2fc99c40c3fc737bd05af6c6abfd74674838a8e8f3fbe32840bbdce57bf964e5fdf63a846bfdd9072ff51037ebfd6f78282fc9f22bf731a61552f87573fa2e6ebdcdd66223fb50c03ef4dd6223fdb96d8899971563fa15a0c1003ae353fcdb115f78e16843fcbf4cd06837ccdbfd5ff93ff25e56d3fc3c589f7e600253fce89b8fbdf89e9bfccb17400d8c2fabfc7d54805fe1bcf3fbfc91c13310a39bfd42c697ff65a653fb553dffbfe93993fbe1f7007cfd81a3fc6c54808ad4dacbfa77528202fa057bfc1eb0e0073c3463fdf33a90f586298bfc1ae6af76fb8a0bfd7c223fc5e8ad03fd6cc70867ad8e4bfb6e3e3eaa09d44bfd4a10e82fa9bbdbfd197ccfb45dc02bfd136daf3003d3d3fc5416a02a825f93fcd4d1afb58fc463fb8e9a5f6743b10bfa2fb98115943be3fd9bf6d7e32b5e0bfd6e40400c09a39bf42f007398531d9bfd7d60f004e03993fdecd4c843d11033fba2d6614b1e8c6bfd36a7d820bde5bbfd49b8b0b615d12bfd8543104afbd1dbf98ca600b0292813fdfb0b2044990c33fd4967b82017779bfb1e000055e63b93fdd56397d4f361e3fc168fdf05b474e3fdeddb57d4fe1ebbfd40b9001147d103fb1a645fa602de83fd3da79fec99f1bbfceffb1fc66ee4c3fae75102261ffa4bfd9da1371cccbf6bfd982bc0782ab41bf9d52efbc10111abf78a9dfe2d420283fc133680c58d3d73fb29a5602152e10bfb12a840d1567453fc27e05ffc94e683fcca9f8f7ce0257bfda5ef502f6d55f3fd5e37403320e9bbfd3f4d1836ad9123fcb489bfb1dc3093f96b69fb9c431733fc1018e0a195e763fd1590986917f19bfd54279011db74b3fae014bda73ff563fc60e5cfa81e6cabfc779fc04f3afbb";
    __pos = __hexstring;
    for (__loopindex=0; __loopindex<1152; __loopindex++)
    {
        sscanf(__pos,"%2x",&__bdata[__loopindex]);
        __pos += 2;
    }
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,288,"W2");
    free(__bdata);  //1

    //3) storing variable W1
    //----------------

    //4) storing variable W1: allocating blob of size 384 plus 3 because we need an extra 3 bytes to fill out the");
    //last 'unsigned char' to be a full 'int' in size, so that it sscanf properly with %2x. (otherwise it's nasty!!!)");
    __bdata = (unsigned char*)malloc(384+3);
    __hexstring = "bfdad157e1686544bfe1b626cdca22ce3fd919317f53f31cbfce5df1f8ab4cf5bfd8ca2b5cd00fa2bfc0564b7ba96ea4bfe2d6e371540032bfd679bb01f420fabfbbf840eedd98cdbfc0c4db7c3d125abfc68f7781c1b6993fae50e824ecf460bfdad157e1686544bfe1b626cdca22ce3fd919317f53f31cbfce5df1f8ab4cf5bfd8ca2b5cd00fa2bfc0564b7ba96ea4bfe2d6e371540032bfd679bb01f420fabfbbf840eedd98cdbfc0c4db7c3d125abfc68f7781c1b6993fae50e824ecf4603fdad157e1686544bfe1b626cdca22ce3fd919317f53f31cbfce5df1f8ab4cf5bfd8ca2b5cd00fa2bfc0564b7ba96ea4bfe2d6e371540032bfd679bb01f420fabfbbf840eedd98cdbfc0c4db7c3d125abfc68f7781c1b6993fae50e824ecf4603fdad157e1686544bfe1b626cdca22ce3fd919317f53f31cbfce5df1f8ab4cf5bfd8ca2b5cd00fa2bfc0564b7ba96ea4bfe2d6e371540032bfd679bb01f420fabfbbf840eedd98cdbfc0c4db7c3d125abfc68f7781c1b6993fae50e824ecf460";
    __pos = __hexstring;
    for (__loopindex=0; __loopindex<384; __loopindex++)
    {
        sscanf(__pos,"%2x",&__bdata[__loopindex]);
        __pos += 2;
    }
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,96,"W1");
    free(__bdata);  //1

    //3) storing variable .LC1
    //----------------

    //4) storing variable .LC1: allocating blob of size 4 plus 3 because we need an extra 3 bytes to fill out the");
    //last 'unsigned char' to be a full 'int' in size, so that it sscanf properly with %2x. (otherwise it's nasty!!!)");
    __bdata = (unsigned char*)malloc(4+3);
    __hexstring = "59800004";
    __pos = __hexstring;
    for (__loopindex=0; __loopindex<4; __loopindex++)
    {
        sscanf(__pos,"%2x",&__bdata[__loopindex]);
        __pos += 2;
    }
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,1,".LC1");
    free(__bdata);  //1

    //3) storing variable .LC3
    //----------------

    //4) storing variable .LC3: allocating blob of size 4 plus 3 because we need an extra 3 bytes to fill out the");
    //last 'unsigned char' to be a full 'int' in size, so that it sscanf properly with %2x. (otherwise it's nasty!!!)");
    __bdata = (unsigned char*)malloc(4+3);
    __hexstring = "3f800000";
    __pos = __hexstring;
    for (__loopindex=0; __loopindex<4; __loopindex++)
    {
        sscanf(__pos,"%2x",&__bdata[__loopindex]);
        __pos += 2;
    }
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,1,".LC3");
    free(__bdata);  //1

    //3) storing variable .LC4
    //----------------

    //4) storing variable .LC4: allocating blob of size 8 plus 3 because we need an extra 3 bytes to fill out the");
    //last 'unsigned char' to be a full 'int' in size, so that it sscanf properly with %2x. (otherwise it's nasty!!!)");
    __bdata = (unsigned char*)malloc(8+3);
    __hexstring = "0000000000000000";
    __pos = __hexstring;
    for (__loopindex=0; __loopindex<8; __loopindex++)
    {
        sscanf(__pos,"%2x",&__bdata[__loopindex]);
        __pos += 2;
    }
    storeBytesInDM_RW(getSubsystemIndex(),R_proc1,wdadr_ptr1,__bdata,2,".LC4");
    free(__bdata);  //1
    reserveMemoryForFunction_RW(getSubsystemIndex(),"tanh.fsig",R_proc1,wdadr_ptr1,3);
//setting the total size of the memory map to 2656
   freeScratchMemoryPointers();
}
DllExport void FNN42_RR(void *this_, int R_proc1)
{
    rpcControlStructurePointer = this_;
    int __idata = 0;
    int __inDMCode = 0;
    int __extraData;
    ramPassNumber = 1;
    initializeParameterDataRW(this_);

    loadInstance(this_,R_proc1); //new!

    userSuppliedRamPass1Code(this_,R_proc1);
    saveInstance(this_,R_proc1);   //new!
    freeScratchMemoryPointers();
}
DllExport int FNN42_getDMSize(void *this_, int R_proc1)
{
    return((2656)/4);
}
DllExport void FNN42_INIT(void *this_)
{
    rpcControlStructurePointer = this_;
    ramPassNumber = 0;
    initializeParameterDataRW(this_);

    userSuppliedRamPass0Code(this_);
}
DllExport unsigned int FNN42_getVariableDMOffset(char* variableName)
{
    int returnValue;
    if(strcmp("b", variableName) == 0)
        returnValue = 0;
    else if(strcmp("iqL", variableName) == 0)
        returnValue = 4;
    else if(strcmp("idL", variableName) == 0)
        returnValue = 8;
    else if(strcmp("iq", variableName) == 0)
        returnValue = 12;
    else if(strcmp("id", variableName) == 0)
        returnValue = 16;
    else if(strcmp("Lr", variableName) == 0)
        returnValue = 20;
    else if(strcmp("u2", variableName) == 0)
        returnValue = 24;
    else if(strcmp("u1", variableName) == 0)
        returnValue = 28;
    else if(strcmp("L", variableName) == 0)
        returnValue = 32;
    else if(strcmp("x4", variableName) == 0)
        returnValue = 36;
    else if(strcmp("x3", variableName) == 0)
        returnValue = 40;
    else if(strcmp("x2", variableName) == 0)
        returnValue = 44;
    else if(strcmp("x1", variableName) == 0)
        returnValue = 48;
    else if(strcmp("d", variableName) == 0)
        returnValue = 52;
    else if(strcmp("q", variableName) == 0)
        returnValue = 56;
    else if(strcmp("numInputs", variableName) == 0)
        returnValue = 60;
    else if(strcmp("numOutputs", variableName) == 0)
        returnValue = 64;
    else if(strcmp("dt", variableName) == 0)
        returnValue = 72;
    else if(strcmp("firstTimeStep", variableName) == 0)
        returnValue = 80;
    else if(strcmp("OverrunFlag", variableName) == 0)
        returnValue = 84;
    else if(strcmp("backprop11_M", variableName) == 0)
        returnValue = 88;
    else if(strcmp("backprop11_Y", variableName) == 0)
        returnValue = 96;
    else if(strcmp("backprop11_U", variableName) == 0)
        returnValue = 112;
    else if(strcmp("iqloss", variableName) == 0)
        returnValue = 216;
    else if(strcmp("idloss", variableName) == 0)
        returnValue = 224;
    else if(strcmp("bn", variableName) == 0)
        returnValue = 232;
    else if(strcmp("b32", variableName) == 0)
        returnValue = 240;
    else if(strcmp("b31", variableName) == 0)
        returnValue = 248;
    else if(strcmp("b2", variableName) == 0)
        returnValue = 256;
    else if(strcmp("b1", variableName) == 0)
        returnValue = 352;
    else if(strcmp("W3", variableName) == 0)
        returnValue = 448;
    else if(strcmp("W2", variableName) == 0)
        returnValue = 640;
    else if(strcmp("W1", variableName) == 0)
        returnValue = 1792;
    else if(strcmp(".LC1", variableName) == 0)
        returnValue = 2176;
    else if(strcmp(".LC3", variableName) == 0)
        returnValue = 2180;
    else if(strcmp(".LC4", variableName) == 0)
        returnValue = 2184;
    else 
        returnValue = 0xFFFFFFFF;  // Signal that the variable was not found.
    return returnValue;
}
