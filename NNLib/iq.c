VERSION:
3.001

// Include file below is generated by C-Builder    
// and contains the variables declared as -        
// PARAMETERS, INPUTS, OUTPUTS . . .               
#include "SimpleNN1.h"

STATIC:

// ----------------------------------------------- 
// Variables declared here may be used in both the 
// RAM: and CODE: sections below.                  
// ----------------------------------------------- 


double dt;

int firstTimeStep = 1;

int OverrunFlag = 0;


// - E n d   o f   S T A T I C :   S e c t i o n - 

RAM_FUNCTIONS:

// ----------------------------------------------- 
// This section should contain any 'c' functions   
// to be called from the RAM section (either       
// RAM_PASS1 or RAM_PASS2). Example:               
//                                                 
// static double myFunction(double v1, double v2)  
// {                                               
//     return(v1*v2);                              
// }                                               
// ----------------------------------------------- 


RAM:

// ----------------------------------------------- 
// Place C code here which computes constants      
// required for the CODE: section below.  The C    
// code here is executed once, prior to the start  
// of the simulation case.                         
// ----------------------------------------------- 


dt= getTimeStep();


// ---- E n d   o f   R A M :   S e c t i o n ---- 

CODE_FUNCTIONS:

// ----------------------------------------------- 
//                                                 
//                                                 
//                                                 
// ----------------------------------------------- 

#include "backprops1.h"
#include <math.h>
#include "rtwtypes.h"



ExternalInputs_backprops1_T backprops1_U;

ExternalOutputs_backprops1_T backprops1_Y;

static RT_MODEL_backprops1_T backprops1_M_;

RT_MODEL_backprops1_T *backprops1_M;

RT_MODEL_backprops1_T *backprops1_M;


real_T W1[12] = {
    -9.6693027e-01, -7.9566032e-01,
    -3.6234397e-01,  2.6165941e-01,
     7.0230091e-01,  3.1332740e-01,
     1.0208109e-04,  7.0201004e-01,
     5.7097507e-01, -6.5944248e-01,
    -2.2743329e-01,  1.4106381e-01
};

real_T b1[6] = {
     3.3662908e-04,  6.7195459e-04, -1.7046472e-03, -4.1860654e-05,
    -5.0049077e-04,  3.9951038e-04
};

real_T W2[6] = {
    -9.2498535e-01,
    -4.3166721e-01,
     1.8799922e-01,
     2.9125609e-04,
    -6.0379976e-01,
    -7.0922780e-01
};

double b2 = 2.4912293e-05;

int32_T bn = 0;

double idloss = 0.0;


static void calcNewArray1(real_T z1[6], int32_T N, int32_T bn, double idloss) {
   
    double dLoss_da3 = idloss / bn;
    // Calculate network output
  
    double dLoss_dW3[N];
	double dLoss_dW1[N * 2];
    double dLoss_db1[N];
    double alpha = backprops1_U.Lr;

    for (int i = 0; i < N; i++) {
        dLoss_dW3[i] = z1[i] * dLoss_da3;
	   dLoss_db1[i] = W2[i] * dLoss_da3;
	dLoss_dW1[2 *i] = dLoss_db1[i] * backprops1_U.x1;
      dLoss_dW1[2 *i + 1] = dLoss_db1[i] * backprops1_U.x2;
	W2[i] = W2[i] - alpha * dLoss_dW3[i];
     b1[i] = b1[i] - alpha * dLoss_db1[i];
	W1[2*i] = W1[2*i] - alpha * dLoss_dW1[2*i];
	W1[2*i+1] = W1[2*i+1] - alpha * dLoss_dW1[2*i+1];
	   
}
    
    
    b2 = b2 - alpha * dLoss_da3;
    
    
}


real_T prev = 0.0;
void backprops1_step(void)
{
    int32_T batch = backprops1_U.b;
    int32_T N = backprops1_U.u1; 
    //real_T a1[N];
    real_T z1[N];
    real_T preOutput;
    int32_T i;
    int32_T k;

	preOutput = 0.0;
    for (k = 0; k < N; k++) {
            z1[k] = backprops1_U.x1 * W1[2 * k] + backprops1_U.x2 * W1[2 * k + 1] + b1[k];
		preOutput += z1[k] * W2[k];

        }        

    
        backprops1_Y.y = preOutput + b2;
        

        if (backprops1_U.Lr > 0.0)
        {
		 idloss += 2 * (backprops1_Y.y - backprops1_U.id);
    
		 bn++;
		 if (batch == bn){
            calcNewArray1(z1, N, bn, idloss);
            bn = 0;
            idloss = 0.0;
            
        }
       }


	if (fabs(backprops1_Y.y - prev )> a){

		if (backprops1_Y.y - prev > 0){
			backprops1_Y.y = prev + a;
		}
		else{
			backprops1_Y.y = prev - a;
			}
		}
   
	prev = backprops1_Y.y; 




    }







void backprops1_terminate(void)
{
  
}


void rt_OneStep(void)
{
	
	
	
	
	if (OverrunFlag) {
		rtmSetErrorStatus(backprops1_M, "Overrun");
		return;
		}
	
	OverrunFlag = true;
	
	
	
	
	
	
	backprops1_step();
	
	
	
	
	OverrunFlag = false;
	
	
	
	
	}



void backprops1_initialize(void)
{
  
}


CODE:

// ----------------------------------------------- 
// Place C code here which runs on the RTDS. The   
// code below is entered once each simulation      
// step.                                           
// ----------------------------------------------- 


backprops1_U.a = a;
backprops1_U.b = b;
backprops1_U.id = id;
backprops1_U.Lr = Lr;
backprops1_U.u1 = u1;
backprops1_U.x2 = x2;
backprops1_U.x1 = x1;

if (firstTimeStep == 1)
{
	backprops1_M =  &backprops1_M_;
	backprops1_M =  &backprops1_M_;
	backprops1_initialize();
	firstTimeStep = 0;
}
else
{
	rt_OneStep();
}

y = backprops1_Y.y;

// ---- E n d   o f   C O D E :  S e c t i o n --- 
