VERSION:
3.001

// Include file below is generated by C-Builder    
// and contains the variables declared as -        
// PARAMETERS, INPUTS, OUTPUTS . . .               
#include "SimpleNN1.h"

STATIC:

// ----------------------------------------------- 
// Variables declared here may be used in both the 
// RAM: and CODE: sections below.                  
// ----------------------------------------------- 


double dt;

int firstTimeStep = 1;

int OverrunFlag = 0;


// - E n d   o f   S T A T I C :   S e c t i o n - 

RAM_FUNCTIONS:

// ----------------------------------------------- 
// This section should contain any 'c' functions   
// to be called from the RAM section (either       
// RAM_PASS1 or RAM_PASS2). Example:               
//                                                 
// static double myFunction(double v1, double v2)  
// {                                               
//     return(v1*v2);                              
// }                                               
// ----------------------------------------------- 


RAM:

// ----------------------------------------------- 
// Place C code here which computes constants      
// required for the CODE: section below.  The C    
// code here is executed once, prior to the start  
// of the simulation case.                         
// ----------------------------------------------- 


dt= getTimeStep();


// ---- E n d   o f   R A M :   S e c t i o n ---- 

CODE_FUNCTIONS:

// ----------------------------------------------- 
//                                                 
//                                                 
//                                                 
// ----------------------------------------------- 

#include "backprops1.h"
#include <math.h>
#include "rtwtypes.h"



ExternalInputs_backprops1_T backprops1_U;

ExternalOutputs_backprops1_T backprops1_Y;

static RT_MODEL_backprops1_T backprops1_M_;

RT_MODEL_backprops1_T *backprops1_M;

RT_MODEL_backprops1_T *backprops1_M;


real_T W1[12] = { -0.47516575, -0.04411472, 0.43981662,  0.23292284, 0.3935827,  -0.15648066, -0.88010156, -1.1782408,     0.04591165,  0.59174347,  -0.31446916,  0.9284628 };  

real_T b1[6] = { 0.00025481, -0.00580862, -0.0058165, 0.00048616, -0.00166244, 0.00156747 };

real_T W2[6] = { -0.9715969, 0.03685118, -0.01070512, -0.66911244, -0.05166966, 0.19118463 };

double b2 = 0.00024953;

int32_T bn = 0;

double idloss = 0.0;

real_T prev = 0.0;

static void calcNewArray1(real_T z1[6], int32_T N, int32_T bn, double idloss) {
   
    double dLoss_da3 = idloss / bn;
    // Calculate network output
  
    double dLoss_dW3[N];
	double dLoss_dW1[N * 2];
    double dLoss_db1[N];
    double alpha = backprops1_U.Lr;

    for (int i = 0; i < N; i++) {
        dLoss_dW3[i] = z1[i] * dLoss_da3;
	   dLoss_db1[i] = W2[i] * dLoss_da3;
	dLoss_dW1[2 *i] = dLoss_db1[i] * backprops1_U.x1;
      dLoss_dW1[2 *i + 1] = dLoss_db1[i] * backprops1_U.x2;
	W2[i] = W2[i] - alpha * dLoss_dW3[i];
     b1[i] = b1[i] - alpha * dLoss_db1[i];
	W1[2*i] = W1[2*i] - alpha * dLoss_dW1[2*i];
	W1[2*i+1] = W1[2*i+1] - alpha * dLoss_dW1[2*i+1];
	   
}
    
    
    b2 = b2 - alpha * dLoss_da3;
    
    
}



void backprops1_step(void)
{
    int32_T batch = backprops1_U.b;
    int32_T N = backprops1_U.u1; 
    //real_T a1[N];
    real_T z1[N];
    real_T preOutput;
    int32_T i;
    int32_T k;

	preOutput = 0.0;
    for (k = 0; k < N; k++) {
            z1[k] = backprops1_U.x1 * W1[2 * k] + backprops1_U.x2 * W1[2 * k + 1] + b1[k];
		preOutput += z1[k] * W2[k];

        }        

    
        backprops1_Y.y = preOutput + b2;
        

        if (backprops1_U.Lr > 0.0)
        {
		 idloss += 2 * (backprops1_Y.y - backprops1_U.id);
    
		 bn++;
		 if (batch == bn){
            calcNewArray1(z1, N, bn, idloss);
            bn = 0;
            idloss = 0.0;
            
        }
       }

	if (fabs(backprops1_Y.y - prev )> limit){

		if (backprops1_Y.y - prev > 0){
			backprops1_Y.y = prev + limit;
		}
		else{
			backprops1_Y.y = prev - limit;
			}
		}
   
	prev = backprops1_Y.y; 
 }







void backprops1_terminate(void)
{
  
}


void rt_OneStep(void)
{
	
	
	
	
	if (OverrunFlag) {
		rtmSetErrorStatus(backprops1_M, "Overrun");
		return;
		}
	
	OverrunFlag = true;
	
	
	
	
	
	
	backprops1_step();
	
	
	
	
	OverrunFlag = false;
	
	
	
	
	}



void backprops1_initialize(void)
{
  
}


CODE:

// ----------------------------------------------- 
// Place C code here which runs on the RTDS. The   
// code below is entered once each simulation      
// step.                                           
// ----------------------------------------------- 


backprops1_U.a = a;
backprops1_U.b = b;
backprops1_U.id = id;
backprops1_U.Lr = Lr;
backprops1_U.u1 = u1;
backprops1_U.x2 = x2;
backprops1_U.x1 = x1;

if (firstTimeStep == 1)
{
	backprops1_M =  &backprops1_M_;
	backprops1_M =  &backprops1_M_;
	backprops1_initialize();
	firstTimeStep = 0;
}
else
{
	rt_OneStep();
}


y = backprops1_Y.y;

// ---- E n d   o f   C O D E :  S e c t i o n --- 