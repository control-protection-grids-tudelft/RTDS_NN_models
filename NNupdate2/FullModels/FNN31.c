VERSION:
3.001

// Include file below is generated by C-Builder    
// and contains the variables declared as -        
// PARAMETERS, INPUTS, OUTPUTS . . .               
#include "FNN31.h"

STATIC:

// ----------------------------------------------- 
// Variables declared here may be used in both the 
// RAM: and CODE: sections below.                  
// ----------------------------------------------- 


double dt;

int firstTimeStep = 1;

int OverrunFlag = 0;


// - E n d   o f   S T A T I C :   S e c t i o n - 

RAM_FUNCTIONS:

// ----------------------------------------------- 
// This section should contain any 'c' functions   
// to be called from the RAM section (either       
// RAM_PASS1 or RAM_PASS2). Example:               
//                                                 
// static double myFunction(double v1, double v2)  
// {                                               
//     return(v1*v2);                              
// }                                               
// ----------------------------------------------- 


RAM:

// ----------------------------------------------- 
// Place C code here which computes constants      
// required for the CODE: section below.  The C    
// code here is executed once, prior to the start  
// of the simulation case.                         
// ----------------------------------------------- 


dt= getTimeStep();


// ---- E n d   o f   R A M :   S e c t i o n ---- 

CODE_FUNCTIONS:

// ----------------------------------------------- 
//                                                 
//                                                 
//                                                 
// ----------------------------------------------- 

#include "backprop99.h"
#include <math.h>
#include "rtwtypes.h"



ExternalInputs_backprop99_T backprop99_U;

ExternalOutputs_backprop99_T backprop99_Y;

static RT_MODEL_backprop99_T backprop99_M_;

RT_MODEL_backprop99_T *backprop99_M;

RT_MODEL_backprop99_T *backprop99_M;




real_T W1[36] = { -0.4190273, -0.5534853, 0.39216268, -0.23724198,
                 -0.38733944, -0.12763351, -0.5887315, -0.35117984,
                 -0.1092568, -0.13100761, -0.17625326, 0.05921102, -0.4190273, -0.5534853, 0.39216268, -0.23724198,
                 -0.38733944, -0.12763351, -0.5887315, -0.35117984,
                 -0.1092568, -0.13100761, -0.17625326, 0.05921102, 0.4190273, -0.5534853, 0.39216268, -0.23724198,
                 -0.38733944, -0.12763351, -0.5887315, -0.35117984,
                 -0.1092568, -0.13100761, -0.17625326, 0.05921102 };

real_T W2[144] = { -0.47471857, -0.36507237, -0.26847112,  0.26465452,  0.3381679,  -0.46993554,
                  -0.2728821,   0.30178487, -0.08691764,  0.1659472,   0.26840556,  0.06906676,
                   0.00992882,  0.3794726,  -0.15999973, -0.03256416,  0.3409729,  -0.14118636,
                  -0.15606761, -0.2748748,  -0.37460172,  0.06245673, -0.19025242, -0.2548777,
                  -0.1182909,   0.12473583, -0.352821,    0.3157717,   0.4131291,  -0.04205751,
                  -0.4600469,   0.08799601, -0.29915333,  0.16575181, -0.44299233,  0.4389025,
                  -0.06205738, -0.03392494,  0.14247632, -0.01960182, -0.33262563, -0.23348916,
                  -0.01264894, -0.20673144,  0.11727512,  0.14143229,  0.29430652, -0.4180094,
                   0.19837034,  0.17718148, -0.46724868, -0.15838182, -0.30619764, -0.2167319,
                  -0.23547804, -0.4475087,  -0.4774351,  -0.22066319,  0.21331322,  0.15136278,
                   0.16183412,  0.07552624,  0.34318602,  0.41802728,  0.13098228, -0.28556132,
                   0.1813885,  -0.36367524,  0.11795831, -0.02178335, -0.46194148, -0.3588568,
                  -0.00466383,  0.03691804,  0.08221459,  0.4310819,   0.03389013,  0.23196673,
                   0.21840823, -0.34372425,  0.15446591,  0.23857796, -0.22416544, -0.18619633,
                   0.12416244, -0.3152107,   0.08331108,  0.1176672,   0.17789555, -0.04581571,
                  -0.1399858,   0.4875281,  -0.13813531, -0.3712244,   0.356228,   -0.08941483,
                  -0.32233012, -0.27489018, -0.2689731,   0.16605878,  0.22891557,  0.09731519,
                  -0.03707576,  0.40230882, -0.35766697, -0.00057793, -0.3724401,   0.48128045,
                   0.10225523, -0.30337465, -0.3219936,  -0.38013864, -0.0242095,   0.49515963,
                   0.32168472, -0.06982422,  0.45838773,  0.1360166,   0.48228204, -0.31320572,
                   0.06894338,  0.31020975, -0.2421782,   0.05948687, -0.4039353,  -0.3986044,
                  -0.02863669, -0.00602138,  0.1343813,   0.07266748, -0.06705499,  0.14447093,
                   0.22393715, -0.41204572,  0.34200764, -0.31181753,  0.21315336,  0.02218103,
                   0.13285995,  0.2710594,  -0.33218217,  0.05860364,  0.17231333, -0.18341017 };

real_T W3[12] = { 0.15099627, -0.6298067,  0.07181972, -0.11471337,
                 0.583267,    0.55912733, -0.1215806, -0.5711195,
                 0.03680378,  0.01584715, -0.16391218, -0.18074852 };

real_T b1[12] = { 0.0, -0.0, 0.0,
                 0.0, -0.0, 0.0, -0.0, 0.0,
                 0.0, -0.0, 0.0, 0.0 };

real_T b2[12] = { 0.0, -0.0, -0.0, 0.0,
                 -0.0, 0.0, 0.0, 0.0, -0.0, 0.0,
                 -0.0, -0.0 };


double b3 = 0.0;

int32_T bn = 0;

double idloss = 0.0;





static void calcNewArray1(real_T a1[12], int32_T N, int32_T bn, double idloss) {
   
    double dLoss_da3 = idloss / bn;
    // Calculate network output
  
    double dLoss_dW3[N];
    for (int i = 0; i < N; i++) {
        dLoss_dW3[i] = a1[i] * dLoss_da3;
}
        double da1_dz1[N];
    for (int i = 0; i < N; i++) {
            da1_dz1[i] = 1 - a1[i] * a1[i];
        }

    
    double dLoss_dW1[N * 3];
    double dLoss_db1[N];
    for (int k = 0; k < N; k++) {
        double TT = W3[k] * dLoss_da3;

        dLoss_dW1[3 *k] = TT * da1_dz1[k] * backprop99_U.x1;
        dLoss_dW1[3 *k + 1] = TT * da1_dz1[k] * backprop99_U.x2;
        dLoss_dW1[3 *k + 2] = TT * da1_dz1[k] * backprop99_U.x3;
        dLoss_db1[k] = TT * da1_dz1[k];
    }

    double alpha = backprop99_U.Lr;
    b3 = b3 - alpha * dLoss_da3;
    
    
        for (int i = 0; i < N; i++)
        {
            W3[i] = W3[i] - alpha * dLoss_dW3[i];
        }
   


    for (int i = 0; i < N * 3; i++)
    {
        W1[i] = W1[i] - alpha * dLoss_dW1[i];
    }
    for (int i = 0; i < N; i++)
    {
        b1[i] = b1[i] - alpha * dLoss_db1[i];
    }
}


static void calcNewArray(real_T a2[12], real_T a1[12], real_T z2[12], int32_T N, int32_T N2, int32_T bn, double idloss)
{

    

    double dLoss_da3 = idloss / bn;
   


    double dLoss_dW3[N2];

    for (int i = 0; i < N2; i++)
    {
        dLoss_dW3[i] = a2[i] * dLoss_da3;
    }


    double dLoss_da2[N2];

    for (int i = 0; i < N2; i++)
    {
        dLoss_da2[i] = W3[i] * dLoss_da3;

    }

    double da2_dz2[N2];

    for (int i = 0; i < N2; i++)
    {
        da2_dz2[i] = 1 - tanh(z2[i]) * tanh(z2[i]);
    }

    double dLoss_dz2[N2];
    for (int i = 0; i < N2; i++)
    {
        dLoss_dz2[i] = dLoss_da2[i] * da2_dz2[i];
    }


    double dLoss_dW2[N * N2];

    for (int k = 0; k < N2; k++)
    {
        for (int i = 0; i < N; i++)
        {

            dLoss_dW2[12 * k + i] = W3[k] * dLoss_da3 * (1 - a2[k] * a2[k]) * a1[i];

        }

    }


    double da1_dz1[N];
    for (int i = 0; i < N; i++)
    {
        da1_dz1[i] = 1 - a1[i] * a1[i];
    }

    double dLoss_dW1[N * 3];
    double dLoss_db1[N];


    for (int k = 0; k < N; k++)
    {
        real_T tmp = 0.0;
        for (int i = 0; i < N2; i++)
        {

            tmp += W3[i] * dLoss_da3 * (1 - a2[i] * a2[i]) * W2[12 * i + k];
        }
        dLoss_dW1[3 * k] = tmp * da1_dz1[k] * backprop99_U.x1;
        dLoss_dW1[3 * k + 1] = tmp * da1_dz1[k] * backprop99_U.x2;
        dLoss_dW1[3 * k + 2] = tmp * da1_dz1[k] * backprop99_U.x3;
        dLoss_db1[k] = tmp * da1_dz1[k];
    }



    double alpha = backprop99_U.Lr;



    
        for (int i = 0; i < N2; i++)
        {
            W3[i] = W3[i] - alpha * dLoss_dW3[i];
        }
    

    b3 = b3 - alpha * dLoss_da3;

    for (int k = 0; k < N2; k++)
    {

        for (int i = 0; i < N; i++)
        {
            W2[12 * k + i] = W2[12 * k + i] - alpha * dLoss_dW2[N2 * k + i];
        }
    }



    for (int i = 0; i < N2; i++)
    {
        b2[i] = b2[i] - alpha * dLoss_dz2[i];
    }

    for (int i = 0; i < N * 3; i++)
    {
        W1[i] = W1[i] - alpha * dLoss_dW1[i];
    }
    for (int i = 0; i < N; i++)
    {
        b1[i] = b1[i] - alpha * dLoss_db1[i];
    }
}











void Subsystem_step(void)
{
    int32_T N = backprop99_U.u1;
    int32_T N2 = backprop99_U.u2;
    int32_T Ly = backprop99_U.L;
    int32_T batch = backprop99_U.b; 
    real_T a1[N];
    real_T z1[N];
    real_T a2[N];
    real_T z2[N];
    real_T preOutput;
    real_T preOutput2;
    real_T tmp;
    int32_T i;
    int32_T k;

    


    if (Ly < 2) {
        for (k = 0; k < N; k++) {
            z1[k] = backprop99_U.x1 * W1[3 * k] + backprop99_U.x2 * W1[3 * k + 1] + backprop99_U.x3 * W1[3 * k + 2] + b1[k];
            a1[k] = tanh(z1[k]);
        }

        preOutput = 0.0;
        
        for (k = 0; k < N; k++) {
            preOutput += a1[k] * W3[k];
         }

        backprop99_Y.y = preOutput + b3;
        

        if (backprop99_U.Lr > 0.0)
        {
		 idloss += 2 * (backprop99_Y.y - backprop99_U.id);
    
		 bn++;
		 if (batch == bn){
            calcNewArray1(a1, N, bn, idloss);
            bn = 0;
            idloss = 0.0;
            
        }
       }

    }
    else {

        for (k = 0; k < N; k++)
        {
            z1[k] = backprop99_U.x1 * W1[3 * k] + backprop99_U.x2 * W1[3 * k + 1] + backprop99_U.x3 * W1[3 * k + 2] + b1[k];
            a1[k] = tanh(z1[k]);
        }

        preOutput = 0.0;
        for (k = 0; k < N2; k++)
        {
            tmp = 0.0;
            for (i = 0; i < N; i++)
            {
                tmp += W2[12 * k + i] * a1[i];
            }

            preOutput += tanh(tmp + b2[k]) * W3[k];
            z2[k] = tmp + b2[k];
            a2[k] = tanh(tmp + b2[k]);
        }

        backprop99_Y.y = preOutput + b3;
        

        if (backprop99_U.Lr > 0.0)
        {
		idloss += 2 * (backprop99_Y.y - backprop99_U.id);
        
		bn++;
		if (batch == bn){
            calcNewArray(a2, a1, z2, N, N2, bn, idloss);
            bn = 0;
            idloss = 0.0;
         }
    }
  }
}


void backprop99_terminate(void)
{
  
}


void rt_OneStep(void)
{
	
	
	
	
	if (OverrunFlag) {
		rtmSetErrorStatus(backprop99_M, "Overrun");
		return;
		}
	
	OverrunFlag = true;
	
	
	
	
	
	
	Subsystem_step();
	
	
	
	
	OverrunFlag = false;
	
	
	
	
	}



void backprop99_initialize(void)
{
  
}


CODE:

// ----------------------------------------------- 
// Place C code here which runs on the RTDS. The   
// code below is entered once each simulation      
// step.                                           
// ----------------------------------------------- 


backprop99_U.b = b;
backprop99_U.id = id;
backprop99_U.Lr = Lr;
backprop99_U.u2 = u2;
backprop99_U.u1 = u1;
backprop99_U.L = L;
backprop99_U.x3 = x3;
backprop99_U.x2 = x2;
backprop99_U.x1 = x1;

if (firstTimeStep == 1)
{
	backprop99_M =  &backprop99_M_;
	backprop99_M =  &backprop99_M_;
	backprop99_initialize();
	firstTimeStep = 0;
}
else
{
	rt_OneStep();
}

y = backprop99_Y.y;

// ---- E n d   o f   C O D E :  S e c t i o n --- 