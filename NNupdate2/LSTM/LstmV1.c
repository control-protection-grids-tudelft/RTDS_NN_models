VERSION:
3.001

// Include file below is generated by C-Builder      
// and contains the variables declared as -          
// PARAMETERS, INPUTS, OUTPUTS . . .                 
#include "LstmV1.h"


STATIC:

// -----------------------------------------------   
// Variables declared here may be used in both the   
// RAM: and CODE: sections below.                    
// -----------------------------------------------   
//    double dt;    

int N;
int Y;
int T;
double X[6] = {0.0};

double X1[10] = {0.0};
double X2[10] = {0.0};
double X3[10] = {0.0};
double X4[10] = {0.0};
double X5[10] = {0.0};
double X6[10] = {0.0};
double out[6] = {0.0};
int i;
int k;
int t;
// - E n d   o f   S T A T I C :   S e c t i o n -   

RAM_FUNCTIONS:

// -----------------------------------------------   
// This section should contain any 'c' functions     
// to be called from the RAM section (either         
// RAM_PASS1 or RAM_PASS2). Example:                 
//                                                   
// static double myFunction(double v1, double v2)    
// {                                                 
//     return(v1*v2);                                
// }                                                 
// -----------------------------------------------   

RAM:

N = numInputs;
Y = numOutputs;
T = timesteps;

// -----------------------------------------------   
// Place C code here which computes constants        
// required for the CODE: section below.  The C      
// code here is executed once, prior to the start    
// of the simulation case.                           
// -----------------------------------------------   
//    dt= getTimeStep();                             


// ------------- End of RAM: Section -------------   


CODE_FUNCTIONS:

double sigmoid(double x) {
    return 1.0 / (1.0 + exp(-x));
}

double dervSig(double x){
	return x * (1-x);
}



static void UpdateTimestep(int T, int N){

for (i = 0; i < T-1; i++){

	X1[i] = X1[i+1];
	if (N>1){
		X2[i] = X2[i+1];
		if (N>2){
			X3[i] = X3[i+1];
			if (N>3){
				X4[i] = X4[i+1];
				if (N>4){
					X5[i] = X5[i+1];
					if (N>5){
						X6[i] = X6[i+1];
					}
				}
			}
		}
	}
}
}


static void getX(int N, int t){

X[0] = X1[t];

if(N>1){
X[1] = X2[t];
if(N>2){
	X[2] = X3[t];
	if(N>3){
		X[3] = X4[t];
		if(N>4){
			X[4] = X5[t];
			if(N>5){
				X[5] = X6[t];
			}
		}	
	}
}
}
}


int nodes = 5;
double C[5] = {0.0};
double h[5] = {0.0};
static void FeedForward(int N, int Y){

  for (t = 0; t < T; t++) {
	getX(N,t);

	for (k=0; k < nodes; k++){
	for (i = 0; i < N; i++) { 
		Wfx += X[i]*Wf[i];
		Wix += X[i]*Wi[i];//add k term in brackets
		Wcx += X[i]*Wc[i];
		Wox += X[i]*Wo[i];
	}

	for (i = 0; i < nodes; i++) { 
		hf += h[i]*Uf[i];
		hi += h[i]*Ui[i];//add k term in brackets
		hc += h[i]*Uc[i];
		ho += h[i]*Uo[i];
	}

		C[k] = sigmoid(Wfx + hf +bf[k])* C[k] + sigmoid(Wix 				+ hi +bi[k]) * tanh(Wcx + hc + bc[k]);


		h[k] = sigmoid(Wox+ho+bo[k])*tanh(C[k]);

	}
	}
	for (k=0; k < nodes; k++){
		for (i=0; i < Y; i++){

			out[i] += h[k]*W[i*nodes + k];
		}
	} 
}


Static void FFbackprop(int N, int Y, int nodes){

  for (t = 0; t < T; t++) {
	getX(N,t);

	for (k=0; k < nodes; k++){
	for (i = 0; i < N; i++) {
		iter = nodes*k+i; 
		Wfx[k] += X[i]*Wf[iter];
		Wix[k] += X[i]*Wi[iter];//add k term in brackets
		Wcx[k] += X[i]*Wc[iter];
		Wox[k] += X[i]*Wo[iter];
	}

	for (i = 0; i < nodes; i++) {
		iter = nodes*k + i;   
		hf += h[i]*Uf[iter];
		hi += h[i]*Ui[iter];//add k term in brackets
		hc += h[i]*Uc[iter];
		ho += h[i]*Uo[iter];
	}
		
		Fg[t*nodes+k] = sigmoid(Wfx + hf +bf[k]);
		dFg[t*nodes+k] = Fg[t*nodes+k] * (1 - Fg[t*nodes+k]);

		Ig[t*nodes+k] = sigmoid(Wix + hi +bi[k]); 
		dIg[t*nodes+k] = Ig[t*nodes+k] *(1- Ig[t*nodes+k]);

		Cg[t*nodes+k] = tanh(Wcx + hc + bc[k]);
		dCg[t*nodes+k] = 1 - Cg[t*nodes+k]*Cg[t*nodes+k];
  
		Og[t*nodes+k] = sigmoid(Wox+ho+bo[k]);
		dOg[t*nodes+k] = Og[t*nodes+k] * (1 - Og[t*nodes+k]);

C_all[t*nodes+k]=Fg[t*nodes+k]*C_all[(t-1)*nodes+k]+Ig[t*nodes+k]*Cg[t*nodes+k];
dC = [t*nodes+k]=Og[t*nodes+k]*(1-tanh(C_all[t*nodes+k])*tanh(C_all[t*nodes+k]));


		h_all[t*nodes+k] = Og[t*nodes+k] * tanh(C[k]);

	}
	}
	for (k=0; k < nodes; k++){
		for (i=0; i < Y; i++){

			out[i] += h[k]*W[i*nodes + k];
		}
	} 

}


static void getLoss(int Y){
  for (y = 0; y < Y; y++) {
	
Loss[y] = 
Wloss[]
}







  for (t = T-1; t >= 0; t--) {

	for (k=0; k < nodes; k++){

		hloss[k] = hloss[k]
			

		tf = Lr *hloss[k]*dC[T*t+k]*C_all[T*t+k]*dfg[T*t+k];
		ti = Lr *hloss[k]*dC[T*t+k]*Cg[T*t+k]*dig[T*t+k];
		tc = Lr *hloss[k]*dC[T*t+k]*Ig[T*t+k]*dCg[T*t+k];
		tO = Lr *hloss[k]*tanh(C[T*t+k])*dOg[T*t+k];
		
		for (i=0; i < nodes; i++){		
			iter = nodes*k+i;
Uf[iter] -= tf * h_all[T*t+i];
Ui[iter] -= ti * h_all[T*t+i];
Uc[iter] -= tc * h_all[T*t+i];
Uo[iter] -= tO * h_all[T*t+i];
		}

for (i=0; i < N; i++){
	iter = nodes*k+i;
	Wf[iter] -= tf * X[i]; 
	Wi[iter] -= ti * X[i];
	Wc[iter] -= tc * X[i];
	Wo[iter] -= tO * X[i];	
}

bf[k] -= tf;
bi[k] -= ti;
bc[k] -= tc; 
bo[k] -= tO;

	}


}
















dUf += hloss * dC[4] * C1[5] * df[4] * h1[5]; 
dUi += hloss * dC[4] * c[4] * di[4] * h1[5];
dUc += hloss * dC[4] * I[4] * dc[4] * h1[5];
dUo += hloss * tanh(C1[5]) * doo[4] * h1[5];	
 
dWf[0] += hloss * dC[4] * C1[5] * df[4] * X[4]; 
dWi[0] += hloss * dC[4] * c[4] * di[4] * X[4];
dWc[0] += hloss * dC[4] * I[4] * dc[4] * X[4];
dWo[0] += hloss * tanh(C1[5]) * doo[4] * X[4];	


dWf[1] += hloss * dC[4] * C1[5] * df[4] * XX[4]; 
dWi[1] += hloss * dC[4] * c[4] * di[4] * XX[4];
dWc[1] += hloss * dC[4] * I[4] * dc[4] * XX[4];
dWo[1] += hloss * tanh(C1[5]) * doo[4] * XX[4];


dbf += hloss * dC[4] * C1[5] * df[4]; 
dbi += hloss * dC[4] * c[4] * di[4];
dbc += hloss * dC[4] * I[4] * dc[4];
dbo += hloss * tanh(C1[5]) * doo[4];




CODE:

UpdateTimestep(T, N);
X1[T-1] = x1;

if (N>1){
	X2[T-1] = x2;
	if (N>2){
		X3[T-1] = x3;
		if (N>3){
			X4[T-1] = x4;
			if (N>4){
				X5[T-1] = x5;
				if (N>5){
					X6[T-1] = x6;
				}
			}
		}
	}
}

FeedForward(N,Y);

foutput = out[0];
out[0] = 0.0;
if (Y>1){
	foutput2 = out[1];
	out[1] = 0.0;
	if (Y>2){
		foutput3 = out[2];
		out[2] = 0.0;
		if (Y>3){
			foutput4 = out[3];
			out[3] = 0.0;
			if (Y>4){
				foutput5 = out[4];
				out[4] = 0.0;
				if (Y>5){
					foutput6 = out[5];
					out[5] = 0.0;
				}
			}
		}
	}
}



// ------------ End of CODE: Section -------------   
