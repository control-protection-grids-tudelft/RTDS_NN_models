VERSION:
3.001

// Include file below is generated by C-Builder      
// and contains the variables declared as -          
// PARAMETERS, INPUTS, OUTPUTS . . .                 
#include "lstmV2.h"


STATIC:

// -----------------------------------------------   
// Variables declared here may be used in both the   
// RAM: and CODE: sections below.                    
// -----------------------------------------------   
//    double dt;    

int N;
int Y;
int T;
int nodes;

int i;
int k;
int t;
int j;
int y;


double hloss[11] = {0.0};
double dhloss[11] = {0.0};
double Wloss[60] = {0.0};
double h[11] = {0.0};
double h_next[11] = {0.0};
double h_all[110] = {0.0};

double C[11] = {0.0};
double Cprev[11] = {0.0};

double dC[100] = {0.0};
double dfg[100] = {0.0};
double dig[100] = {0.0};
double dcg[100] = {0.0};
double dOg[100] = {0.0};

double Fg = 0.0;
double Ig = 0.0;
double Cg = 0.0;
double Og = 0.0;


double dUf[100] = {0.0};
double dUi[100] = {0.0};
double dUc[100] = {0.0};
double dUo[100] = {0.0};


//double Uf[100] = {0.0};
//double Ui[100] = {0.0};
//double Uc[100] = {0.0};
//double Uo[100] = {0.0};


//double Wf[60] = {0.0};
//double Wi[60] = {0.0};
//double Wc[60] = {0.0};
//double Wo[60] = {0.0};



//double W[60] = {0.0};

double Wfx = 0.0;
double Wcx = 0.0;
double Wix = 0.0;
double Wox = 0.0;
double hf = 0.0;
double hc = 0.0;
double hi = 0.0;
double ho = 0.0;

double loss[6] = {0.0};
double ddc = 0.0;

double X[6] = {0.0};

double X1[10] = {0.0};
double X2[10] = {0.0};
double X3[10] = {0.0};
double X4[10] = {0.0};
double X5[10] = {0.0};
double X6[10] = {0.0};
double out[6] = {0.0};
int iter = 0;
int f = 0.0;
int f2 = 0.0;


double tf = 0.0;
double ti = 0.0;
double tc = 0.0;
double tO = 0.0;


double Wi[10] = { -0.021147491, 0.18431845, -0.5533281, -0.4101665, -0.18496199, -0.2919681, -0.08328365, 0.24529605, -0.25517368, -0.2979334 };
double Wf[10] = { 0.46686363, -0.0064901924, 0.40574425, -0.24206385, 0.005801738, 0.33129448, -0.5611915, 0.21740647, -0.2797794, 0.10430679 };
double Wc[10] = { -0.4674354, -0.026358163, -0.2883451, 0.19021249, 0.4635035, 0.001021428, -0.3953359, -0.49411786, -0.04087297, 0.19105117 };
double Wo[10] = { -0.49317196, -0.041123927, -0.5538398, -0.3980933, -0.31609902, -0.14742438, -0.43189374, 0.606737, -0.5231026, -0.11333405 };
double Ui[25] = { -0.18723813, -0.030597646, -0.39952427, -0.32956395, -0.04654582, 0.06677158, -0.5346876, -0.0579509, 0.153469, 0.1390175, -0.030209454, -0.03082855, -1.0783099, -0.12476894, -0.025950197, 0.44843474, 0.6062068, -0.14504878, -0.0035145504, 0.113632515, 0.03988348, -0.045613337, 0.57412636, -0.5890034, -0.084771566 };
double Uf[25] = { -0.056865852, 0.046868272, -0.2989059, -0.28978506, 0.25312954, -0.032963507, 0.28887373, -0.011608533, -0.004325348, 0.41878316, -0.23609078, 0.3111996, -0.733793, 0.2584029, -0.27194035, 0.07518975, 0.0719664, 0.37170142, 0.10606375, 0.19705509, 0.14062561, 0.5174083, 0.19763757, -0.123840734, -0.23874795 };
double Uc[25] = { -0.455697, 0.1452058, -0.18916467, 0.15371361, 0.04321784, 0.035880342, -0.015091886, -0.1628846, 0.14392143, -0.23119746, 0.21790528, 0.21250223, 0.41307566, 0.25295374, -0.05760703, -0.058342263, -0.14234126, -0.3825206, 0.12947477, -0.1554777, -0.059263416, -0.21252953, -0.13407661, -0.49637917, 0.3140092 };
double Uo[25] = { 0.32713413, -0.250995, 0.06578527, 0.031894933, -0.26401052, -0.21257553, 0.32005242, 0.082551196, 0.4979533, 0.32626262, -0.35065025, 0.006460958, -1.018548, 0.15264125, -0.11179557, -0.1655626, 0.08658418, 0.33554012, 0.21851452, 0.44279978, 0.1886963, -0.42495567, 0.4287737, -0.1712696, -0.13715658 };
double bi[5] = { -0.11408094, 0.17026451, 0.22328661, 0.0056367717, 0.24546596 };
double bf[5] = { 0.86392665, 1.1651214, 1.2085406, 0.9609521, 1.2363702 };
double bc[5] = { 0.0037546197, 0.00086806394, 0.023298984, 0.022541791, 0.015431649 };
double bo[5] = { -0.11495434, 0.20607622, 0.23779702, -0.0061852643, 0.26981583 };
double W[5] = { -0.77711916, -0.8047021, -0.4120008, -0.60443604, 0.7713066 };
double b[1] = { 0.0100115985 };
// - E n d   o f   S T A T I C :   S e c t i o n -   

RAM_FUNCTIONS:

// -----------------------------------------------   
// This section should contain any 'c' functions     
// to be called from the RAM section (either         
// RAM_PASS1 or RAM_PASS2). Example:                 
//                                                   
// static double myFunction(double v1, double v2)    
// {                                                 
//     return(v1*v2);                                
// }                                                 
// -----------------------------------------------   

RAM:
N = numInputs;
nodes = nod;
Y = numOutputs;
T = Timesteps;

// -----------------------------------------------   
// Place C code here which computes constants        
// required for the CODE: section below.  The C      
// code here is executed once, prior to the start    
// of the simulation case.                           
// -----------------------------------------------   
//    dt= getTimeStep();                             


// ------------- End of RAM: Section -------------   

CODE_FUNCTIONS:

double test;

double sigmoid(double x) {
    return 1.0 / (1.0 + exp(-x));
}


static void ResetVar(){

	Wfx = 0.0;
	Wcx = 0.0;
	Wix = 0.0;
	Wox = 0.0;
	hf = 0.0;
	hc = 0.0;
	hi = 0.0;
	ho = 0.0;


}

static void ResetArrays(int nodes){

	for (k=0; k < nodes+1; k++){

hloss[k] = 0.0;
dhloss[k] = 0.0; 
h[k] = 0.0;
C[k] = 0.0;
Cprev[k] = 0.0;
}

}

static void getX(int N, int t){

X[0] = X1[t];

if(N>1){
X[1] = X2[t];
if(N>2){
	X[2] = X3[t];
	if(N>3){
		X[3] = X4[t];
		if(N>4){
			X[4] = X5[t];
			if(N>5){
				X[5] = X6[t];
			}
		}	
	}
}
}
}


static void FeedForward(int N, int Y, int T, int nodes){

  for (t = 0; t < T; t++) {
	getX(N,t);

	for (k=0; k < nodes; k++){
	for (i = 0; i < N; i++) { 
		iter = nodes*k+i; 
		Wfx += X[i]*Wf[iter];
		Wix += X[i]*Wi[iter];//add k term in brackets
		Wcx += X[i]*Wc[iter];
		Wox += X[i]*Wo[iter];
	}

	for (i = 0; i < nodes; i++) { 
		iter = nodes*k+i; 
		hf += h[i]*Uf[iter];
		hi += h[i]*Ui[iter];//add k term in brackets
		hc += h[i]*Uc[iter];
		ho += h[i]*Uo[iter];
	}

		C[k] = sigmoid(Wfx + hf +bf[k])* C[k] + sigmoid(Wix 				+ hi +bi[k]) * tanh(Wcx + hc + bc[k]);


		h_next[k] = sigmoid(Wox+ho+bo[k])*tanh(C[k]);
		ResetVar();
	}

for (k = 0; k < nodes; k++) {
			
		h[k] = h_next[k]; 
	}
	}
	for (k=0; k < nodes; k++){
		for (i=0; i < Y; i++){

			out[i] += h[k]*W[i*nodes + k];
		}
	} 

	for (y = 0; y < Y; y++) {

		out[y] = out[y] + b[y];
	}

}



static void UpdateTimestep(int T, int N){

for (i = 0; i < T-1; i++){

	X1[i] = X1[i+1];
	if (N>1){
		X2[i] = X2[i+1];
		if (N>2){
			X3[i] = X3[i+1];
			if (N>3){
				X4[i] = X4[i+1];
				if (N>4){
					X5[i] = X5[i+1];
					if (N>5){
						X6[i] = X6[i+1];
					}
				}
			}
		}
	}
}
}







static void getLoss(int Y, double Lrr){

loss[0] = L1;
b[0] = b[0] - Lrr * L1;
if(Y>1){
	loss[1] = L2;
	b[1] = b[1] - Lrr * L2;
	if(Y>2){
		loss[2] = L3;
		b[2] = b[2] - Lrr * L3;
		if(Y>3){
			loss[3] = L4;
			b[3] = b[3] - Lrr * L4;
			if(Y>4){
				loss[4] = L5;
				b[4] = b[4] - Lrr * L5;
				if(Y>5){
					loss[5] = L6;
					b[5] = b[5] - Lrr * L6;
				}
			}	
		}
	}
}


for (j = 0; j < nodes; j++) {

	for (y = 0; y < Y; y++) {
		
		Wloss[y*nodes+j] = loss[y] * h[j];
		hloss[j] += loss[y] * W[y*nodes+j]; 
		W[y*nodes+j] = W[y*nodes+j] - Wloss[y*nodes+j]*Lrr;   
	}
}
}

static void FFbackprop(int N, int Y, int nodes){

  for (t = 0; t < T; t++) {
	getX(N,t);

	for (k=0; k < nodes; k++){
	for (i = 0; i < N; i++) {
		iter = nodes*k+i; 
		Wfx += X[i]*Wf[iter];
		Wix += X[i]*Wi[iter];//add k term in brackets
		Wcx += X[i]*Wc[iter];
		Wox += X[i]*Wo[iter];
	}

	for (i = 0; i < nodes; i++) {
		iter = nodes*k + i;   
		hf += h[i]*Uf[iter];
		hi += h[i]*Ui[iter];//add k term in brackets
		hc += h[i]*Uc[iter];
		ho += h[i]*Uo[iter];
	}
		
		Fg = sigmoid(Wfx + hf +bf[k]);
		Ig = sigmoid(Wix + hi +bi[k]); 
		Cg = tanh(Wcx + hc + bc[k]);
		Og = sigmoid(Wox+ho+bo[k]);
		

		C[k]=Fg*Cprev[k]+Ig*Cg;

		h_next[k] = Og * tanh(C[k]);

		h_all[t*nodes+k] = Og * tanh(C[k]);

	
	ddc = Og*(1- tanh(C[k])*tanh(C[k]));
	dC[t*nodes+k] =  ddc;

	dOg[t*nodes+k] = tanh(C[k]) * Og * (1 - Og);
	
	dfg[t*nodes+k] = ddc * Cprev[k] * Fg * (1 - Fg);
	
	dig[t*nodes+k] = ddc * Cg * Ig *(1- Ig);
	
	dcg[t*nodes+k] = ddc * Ig * (1 - Cg*Cg);
		ResetVar();
		}

for (k = 0; k < nodes; k++) {
			
	h[k] = h_next[k]; 		
	Cprev[k] = C[k];
}

	}
	for (k = 0; k < nodes; k++) {
			

		for (i=0; i < Y; i++){

			out[i] += h[k]*W[i*nodes + k];
		}

	}

	for (y = 0; y < Y; y++) {

		out[y] = out[y] + b[y];
	}

}

static void ResetWeights(){

double dUf[100] = {0.0};
double dUi[100] = {0.0};
double dUc[100] = {0.0};
double dUo[100] = {0.0};
}



static void UpdateWeights(int N, int Y, int nodes, double Lrr){

for (t = T-1; t >= 0; t--) {
	getX(N,t);
	for (j=0; j < nodes; j++){
		f = nodes*t+j;
		tf = hloss[j]*dfg[f];
		ti = hloss[j]*dig[f];
		tc = hloss[j]*dcg[f];
		tO = hloss[j]*dOg[f];
		
		for (k=0; k < nodes; k++){
			f = j*nodes+k;

			dhloss[k]+= tO*Uo[f]+ti*Ui[f]+tc*Uc[f]+tf*Uf[f];
			
			f2 = t*nodes + k;
		
			dUf[f] += tf* h_all[f2];
			dUi[f] += ti* h_all[f2];
			dUc[f] += tc* h_all[f2];
			dUo[f] += tO* h_all[f2];
		}	

for (i=0; i < N; i++){
	f = nodes*j+i;
	Wf[f] -= Lrr * tf  * X[i]; 
	Wi[f] -= Lrr * ti * X[i];
	Wc[f] -= Lrr * tc * X[i];
	Wo[f] -= Lrr * tO * X[i];	
}



	bf[j] -= Lrr * tf;
	bi[j] -= Lrr * ti;
	bc[j] -= Lrr * tc; 
	bo[j] -= Lrr * tO;  

	}

	for (k=0; k < nodes; k++){

		hloss[k] = hloss[k]*dhloss[k];
		dhloss[k] = 0.0;
	}

	
}

for (i=0; i < nodes*nodes; i++){

Uf[i] = Uf[i] - Lrr * dUf[i];
dUf[i] = 0.0;
Ui[i] = Ui[i] - Lrr * dUi[i];
dUi[i] = 0.0;
Uc[i] = Uc[i] - Lrr * dUc[i];
dUc[i] = 0.0;
Uo[i] = Uo[i] - Lrr * dUo[i];
dUo[i] = 0.0;
}

//ResetWeights();
}





CODE:

UpdateTimestep(T, N);

X1[T-1] = x1;
X2[T-1] = x2;
X3[T-1] = x3;
X4[T-1] = x4;
X5[T-1] = x5;
X6[T-1] = x6;


if (Lr>0.0){


	getLoss(Y, Lr);
	UpdateWeights(N, Y, nodes, Lr);

	FFbackprop(N, Y, nodes);

}

else{

	FeedForward(N, Y, T, nodes);


}


foutput = out[0];
foutput2 = out[1];
foutput3 = out[2];
foutput4 = out[3];
foutput5 = out[4];
foutput6 = out[5];



out[0] = 0.0;
out[1] = 0.0;
out[2] = 0.0;
out[3] = 0.0;
out[4] = 0.0;
out[5] = 0.0;

ResetArrays(nodes);

// -----------------------------------------------   
// Place C code here which runs on the RTDS. The     
// code below is entered once each simulation        
// step.                                             
// -----------------------------------------------   


// ------------ End of CODE: Section -------------   
